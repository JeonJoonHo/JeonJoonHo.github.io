<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>JOON.DEV</title>
    <link>https://jeonjoonho.github.io/</link>
    
    <atom:link href="https://jeonjoonho.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Hello</description>
    <pubDate>Fri, 12 Feb 2021 10:54:41 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>테스트 주도 개발의 패턴</title>
      <link>https://jeonjoonho.github.io/2021/02/11/%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EC%A3%BC%EB%8F%84%20%EA%B0%9C%EB%B0%9C%EC%9D%98%20%ED%8C%A8%ED%84%B4/</link>
      <guid>https://jeonjoonho.github.io/2021/02/11/%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EC%A3%BC%EB%8F%84%20%EA%B0%9C%EB%B0%9C%EC%9D%98%20%ED%8C%A8%ED%84%B4/</guid>
      <pubDate>Thu, 11 Feb 2021 12:01:33 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;테스트-주도-개발-패턴&quot;&gt;&lt;a href=&quot;#테스트-주도-개발-패턴&quot; class=&quot;headerlink&quot; title=&quot;테스트 주도 개발 패턴&quot;&gt;&lt;/a&gt;테스트 주도 개발 패턴&lt;/h1&gt;&lt;p&gt;테스트는 무엇이고,&lt;br&gt;테스트는 언제 해야 하고,&lt;b</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="테스트-주도-개발-패턴"><a href="#테스트-주도-개발-패턴" class="headerlink" title="테스트 주도 개발 패턴"></a>테스트 주도 개발 패턴</h1><p>테스트는 무엇이고,<br>테스트는 언제 해야 하고,<br>테스트 로직은 어떻게 고르고,<br>테스트할 데이터는 어떻게 고를 것인가?</p><h2 id="테스트-명사"><a href="#테스트-명사" class="headerlink" title="테스트(명사)"></a>테스트(명사)</h2><p>테스트하다(test) ‘평가하다’는 뜻의 동사이다. 테스트는 또한 ‘승인 또는 거부에 도달하는 과정’을 뜻하는 명사기도 하다.<br>명사로서의 테스트는 동사로서의 테스트와 다른 느낌을 받을 수 있는데, <strong>변화를 테스트한다는 것(수작업)은 테스트의 동사적 의미를 암시하고, 테스트를 갖고 있다(자동화)는 것은 명사적 의미</strong>를 암시할 수 있다.</p><p>만약, 테스트를 하는 것(수작업)의 대한 스트레스가 증가하게 되면 어떻게 될까?<br>스트레스를 많이 받으면 테스트를 점점 더 뜸하게 한다. 테스트를 뜸하게 하면 당신이 만드는 에러는 점점 많아질 것이고, 에러가 많아지면 더 많은 스트레스를 받게 된다.(양성 피드백 고리- ‘테스트할 시간이 없다’의 죽음의 나선)<br>이 경우에 ‘테스트’를 ‘자동화된 테스트’로 치환하게 되면 개선할 수 있다.</p><p>무엇인가 작업을 할 때 “내가 이걸 고치면서 뭔가 다른 부분을 망가트리지 않았을까?” 라고 생각할 때 자동화된 테스트가 있다면, 테스트를 받기 시작할 때 테스트를 실행할 것이다.<br>테스트를 실행하면 즉시 좋은 느낌을 받게 되고 그러면 작업 중에 에러를 낼 일도 줄게 되며, 스트레스도 적어진다.</p><p>“테스트할 시간이 어딨어. 그냥 릴리즈해!” 이 장면에 대해서는 결과를 보장할 수 없으며 스트레스를 점점 많이 받으며 결국 실패하게 된다.</p><h2 id="격리된-테스트"><a href="#격리된-테스트" class="headerlink" title="격리된 테스트"></a>격리된 테스트</h2><p><strong>테스트를 실행하는 것은 서로 아무 영향이 없어야 한다.</strong></p><p><strong>테스트는 전체 애플리케이션을 대상으로 하는 것보다 좀더 작은 스케일로 하는 게 좋다.</strong> 전체 애플리케이션 대상으로 하게 되면 시간이 너무 오래 걸리기 때문이다.</p><p>각 테스트는 주어진 문제를 작은 단위로 분리하기 위해 노력해 각 테스트를 실행하기 위한 환경을 쉽고 빠르게 세팅할 수 있게 해야 한다.<br>테스트를 격리하기 위한 작업은 결과적으로 시스템이 응집도는 높고 결합도는 낮은 객체의 모음으로 구성되도록 한다.</p><h2 id="테스트-목록"><a href="#테스트-목록" class="headerlink" title="테스트 목록"></a>테스트 목록</h2><p>시작하기 전에 작성해야 할 테스트 목록을 모두 적어두자.</p><ul><li>구현해야 할 것들에 대한 테스트를 목록에 적는다.</li><li>구현할 필요가 있는 모든 함수의 사용 예들을 적는다.</li><li>이미 존재하지 않는 함수에 대해서는 해당 함수의 널 버전을 목록에 적는다.</li><li>이번 작업을 끝내기 전에 반드시 해야 할 리팩토링의 목록을 적는다.</li></ul><p>테스트를 통과하게 만드는 과정에서 새로운 테스트가 필요함을 암시적으로 알려줄 것이다.<br>이 새 테스트를 리팩토링과 마찬가지로 목록에 적자.</p><h2 id="테스트-우선"><a href="#테스트-우선" class="headerlink" title="테스트 우선"></a>테스트 우선</h2><p>테스트 대상이 되는 코드를 작성하기 직전에 테스트를 작성하는 것이 좋다.</p><h2 id="단언-우선"><a href="#단언-우선" class="headerlink" title="단언 우선"></a>단언 우선</h2><ul><li>시스템을 개발할 때 무슨 일부터 하는가? 완료된 시스템이 어떨 거라고 알려주는 이야기부터 작성한다.</li><li>특정 기능을 개발할 때 무슨 일부터 하는가? 기능이 완료되면 통과할 수 있는 테스트부터 작성한다.</li><li>테스트를 개발할 때 무슨 일부터 하는가? 완료될 때 통과해야 할 단언부터 작성한다.</li></ul><p>단언을 먼저 작성함으로써 아주 작은 단계로 빠른 피드백을 받으며 테스트의 아웃라인을 만들 수 있다.</p><h2 id="테스트-데이터"><a href="#테스트-데이터" class="headerlink" title="테스트 데이터"></a>테스트 데이터</h2><ul><li>테스트를 읽을 때 따라가기 좋을 만한 데이터를 사용하라.</li><li>데이터 간에 차이가 있다면 그 속에 어떤 의미가 있어야 한다.</li><li>만약 시스템이 여러 입력을 다루어야 한다면 테스트 역시 여러 입력을 반영해야 한다. 하지만 세 항목만으로 동일한 설계와 구현을 이끌어낼 수 있다면 굳이 항목을 열 개나 나열할 필요는 없다.</li><li>테스트 데이터에 대한 대안은 실제 세상에서 얻어진 실제 데이터를 사용하는 것이다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">실제 데이터는 다음과 같은 경우에 유용하다.</span><br><span class="line">- 실제 실행을 통해 수집한 외부 이벤트의 결과를 이용하여 실시간 시스템을 테스트하고자 하는 경우.</span><br><span class="line">- 예전 시스템의 출력과 현재 시스템의 출력을 비교하고자 하는 경우(병렬 테스팅).</span><br><span class="line">- 시뮬레이션 시스템을 리팩토링한 후 기존과 정확히 동일한 결과가 나오는지 확인하고자 할 경우. 특히 부동소수점 값의 정확성이 문제가 될 수 있다.</span><br></pre></td></tr></table></figure><h2 id="명백한-데이터"><a href="#명백한-데이터" class="headerlink" title="명백한 데이터"></a>명백한 데이터</h2>테스트 자체에 예상되는 값과 실제 값을 포함하고 이 둘 사이의 관계를 드러내기 위해 노력하라.<br>테스트를 작성할 때는 컴퓨터뿐 아니라 후에 코드를 읽을 다른 사람들도 생각해야 한다.</li></ul><p>예를 들어, USD에서 GBP로 교환하는 환율이 2:1이고 수수료 1.5%가 붙는다면 $100는 50GBP - 1.5% = 49.25GBP가 되어야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bank bank = <span class="keyword">new</span> Bank(;</span><br><span class="line">bank.addRate(<span class="string">&quot;USD&quot;</span>, <span class="string">&quot;GBP&quot;</span>, STANDARD_RATE);</span><br><span class="line">bank.commission(STANDARD_COMMISSION);</span><br><span class="line">Money result = bank.convert(<span class="keyword">new</span> Note(<span class="number">100</span>, <span class="string">&quot;USD&quot;</span>), <span class="string">&quot;GBP&quot;</span>);</span><br><span class="line">assertEquals(<span class="keyword">new</span> Note(<span class="number">49.25</span>, <span class="string">&quot;GBP&quot;</span>), result);</span><br></pre></td></tr></table></figure><p>또는 계산을 더 명백하게 표현할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bank bank = <span class="keyword">new</span> Bank(;</span><br><span class="line">bank.addRate(<span class="string">&quot;USD&quot;</span>, <span class="string">&quot;GBP&quot;</span>, <span class="number">2</span>);</span><br><span class="line">bank.commission(<span class="number">0.015</span>);</span><br><span class="line">Money result = bank.convert(<span class="keyword">new</span> Note(<span class="number">100</span>, <span class="string">&quot;USD&quot;</span>), <span class="string">&quot;GBP&quot;</span>);</span><br><span class="line">assertEquals(<span class="keyword">new</span> Note(<span class="number">100</span> / <span class="number">2</span> * (<span class="number">1</span> - <span class="number">0.015</span>), <span class="string">&quot;GBP&quot;</span>), result);</span><br></pre></td></tr></table></figure><p>명백한 데이터를 통해 일단 수식을 써놓으면 어떻게든 나눗셈과 곱셈을 수행할 프로그램을 만들어야 한다는 것을 알수 있기 때문에 다음으로 무엇을 해야 할지 쉽게 알게 된다.<br>명백한 데이터는 코드에 매직넘버를 쓰지 말라는 것에 대한 예외적인 케이스일 수 있다. 단일 메서드라면 이미 정의된 기호 상수를 사용하는 것이 더 나을것이다.</p><hr><h1 id="빨간-막대-패턴"><a href="#빨간-막대-패턴" class="headerlink" title="빨간 막대 패턴"></a>빨간 막대 패턴</h1><p>이 패턴들은 테스트를 언제 어디에 작성할 것인지, 테스트 작성을 언제 멈출지에 대한 것이다.</p><h2 id="한-단계-테스트"><a href="#한-단계-테스트" class="headerlink" title="한 단계 테스트"></a>한 단계 테스트</h2><p>성장은 일종의 자기유사성을 가진 피드백 고리를 암시하는데, 이 피드백 고리에서는 환경이 프로그램에 영향을 주고 프로그램이 다시 환경에 영향을 준다.<br>만약 어떠한 방향성을 가질 필요가 있다면 ‘아는 것에서 모르는 것으로’라는 방향이 유용할 것이다. 우리가 어느 정도의 지식과 경험을 가지고 개발을 시작한다는 점, 개발 하는 중에 새로운 것으로 배우게 될 것임을 예상한다는 점 등을 암시한다.<br>위 두 가지를 통해 우리는 아는 것에서 모르는 것으로 성장하는 프로그램을 갖게 된다.</p><h2 id="시작-테스트"><a href="#시작-테스트" class="headerlink" title="시작 테스트"></a>시작 테스트</h2><p>테스트의 시작은 함수가 아무 일도 하지 않는 경우를 먼저 테스트하는 것이 좋다.<br>현실적인 테스트 하나로 시작하면 너무 오랫동안 피드백이 없을 것이다. 빨강/초록/리팩토링 주기가 몇 분이내로 반복되도록 하자.<br>정말 발견하기 쉬운 입력과 출력을 사용하면 이 시간을 짧게 줄일 수 있다.</p><p>한 단계 테스트는 시작 테스트에도 적용된다. 당신에게 뭔가를 가르쳐줄 수 있으면서도 빠르게 구현할 수 있는 테스트를 선택하라.</p><h2 id="설명-테스트"><a href="#설명-테스트" class="headerlink" title="설명 테스트"></a>설명 테스트</h2><p>자동화된 테스트가 더 널리 쓰이게 하려면 어떻게 해야 할까? 테스트를 통해 설명을 요청하고 테스트를 통해 설명하라.</p><h2 id="학습-테스트"><a href="#학습-테스트" class="headerlink" title="학습 테스트"></a>학습 테스트</h2><p>외부에서 만든 소프트웨어에 대한 테스트를 작성해야 할 때 패키지의 새로운 기능을 처음으로 사용해보기 전에 테스트 작성을 통해 익숙해질 수 있다.<br>그리고 패키지의 새 버전이 도착하면 우선 테스트를 실행해보고, 만약 통과되지 않는다면 애플리케이션을 실행해볼 필요도 없다.</p><h2 id="또-다른-테스트"><a href="#또-다른-테스트" class="headerlink" title="또 다른 테스트"></a>또 다른 테스트</h2><p>주제와 무관한 아이디어가 떠오르면 이에 대한 테스트를 할일 목록에 적어놓고 다시 주제로 돌아와라.<br>대화를 엄격하게 한 주제로 묶는 것은 훌륭한 아이디어를 억압하는 최고의 방법이다. 하지만 내가 가야 할 길을 놓치지 않아야 하며, 새 아이디어가 떠오르면 존중하고 맞이하되 그것이 내 주의를 흩뜨리지 않게 한다.<br>그 아이디어를 목록에 적어놓고는 하던 일로 다시 돌아간다.</p><h2 id="회귀-테스트"><a href="#회귀-테스트" class="headerlink" title="회귀 테스트"></a>회귀 테스트</h2><p>시스템 장애가 보고될 때 그 장애로 인하여 실패하는 테스트, 그리고 통과할 경우엔 장애가 수정되었다고 볼 수 있는 테스트를 가장 간단하게 작성해라.<br>시스템 장애를 손쉽게 격리시킬 수 없다면 리팩토링해야 한다.</p><h2 id="휴식"><a href="#휴식" class="headerlink" title="휴식"></a>휴식</h2><p>키보드로 뭘 쳐야 할지 알면, 명백한 구현을 한다.<br>잘 모르겠다면 가짜 구현을 한다.<br>올바른 설계가 명확하지 않다면 삼각측량 기법을 사용한다.<br>그래도 모르겍ㅆ다면 샤워나 하러 간다.</p><hr><h1 id="테스팅-패턴"><a href="#테스팅-패턴" class="headerlink" title="테스팅 패턴"></a>테스팅 패턴</h1><p>이 패턴들은 더 상세한 테스트 작성법에 대한 것이다.</p><h2 id="자식-테스트"><a href="#자식-테스트" class="headerlink" title="자식 테스트"></a>자식 테스트</h2><p>지나치게 큰 테스트 케이스의 깨지는 부분에 해당하는 작은 테스트 케이스를 작성하고 그 작은 테스트 케이스가 실행되도록 하라.<br>그 후에 다시 원래의 큰 테스트 케이스를 추가하라.</p><h2 id="모의-객체"><a href="#모의-객체" class="headerlink" title="모의 객체"></a>모의 객체</h2><p>비용이 많이 들거나 복잡한 리소스에 의존하는 객체를 테스트할 때 모의 객체를 사용해 이점을 얻을 수 있다.</p><p>한 예로 데이터베이스는 시작 시간도 오래 걸리고, 항상 깨끗한 상태로 유지하기가 어렵다. 또 만약 원격 서버에 있다면 성공 여부가 네트워크 상의 물리적 위치에 영향을 받을 수 있다.<br>이런 경우 <strong>실제 데이터베이스를 사용하는 것이 아닌 데이터베이스인 것처럼 행동하지만 실제로는 메모리에만 존재하는 모의 객체 생성</strong>을 통해 예상된 쿼리를 얻지 못 하면 에러를 반환하고, 올바르다면 결과 집합처럼 보이는 뭔가를 생성해 반환하여 <strong>성능과 견고함</strong>을 얻을 수 있다.<br>그리고 작성 되어 있는 테스트를 끝에서 끝까지 읽을 수 있기 때문에 가독성에도 도움을 받을 수 있다.</p><p>모의 객체가 진짜 객체와 동일하게 동작하지 않는 다는 것은 프로젝트의 위험 요소가 하나 추가되는 것이다.<br>모의 객체용 테스트 집합을 진짜 객체가 사용 가능해질 때 그대로 적용해서 이러한 위험을 줄일 수 있다.</p><h2 id="크래시-테스트-더미"><a href="#크래시-테스트-더미" class="headerlink" title="크래시 테스트 더미"></a>크래시 테스트 더미</h2><p>실제 작업을 수행하는 대신 그냥 예외를 발생시키기만 하는 특수한 객체를 만들어 호출되지 않을 것 같은 에러코드를 테스트 할 수 있다.</p><p>객체 전체를 흉내낼 필요가 없다는 점을 제외하면 크래시 테스트 더미는 모의 객체와 유사하다.<br>자바의 익명 내부 클래스는 우리가 테스트하기 원하는 적절한 메서드만이 오류를 발생키게끔 하기 위해 유용하다.<br>만약 파일 시스템에 여유 공간이 없을 경우 발생할 문제에 대해 테스트하기를 원할 때 익명 내부 클래스를 통해 필요한 함수만 가짜 구현을 통해 테스팅할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileSystemError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File f = <span class="keyword">new</span> File(<span class="string">&quot;foo&quot;</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        saveAs(f);</span><br><span class="line">        fail();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="깨진-테스트"><a href="#깨진-테스트" class="headerlink" title="깨진 테스트"></a>깨진 테스트</h2><p>혼자서 프로그래밍할 때 프로그래밍 세션을 마지막 테스트가 깨진 상태로 끝마치는 것이 좋다.<br>나중에 다시 코딩하기위해 돌아왔을 때, 어느 작업부터 시작할 것인지 명백히 알 수 있다.</p><h2 id="깨끗한-체크인"><a href="#깨끗한-체크인" class="headerlink" title="깨끗한 체크인"></a>깨끗한 체크인</h2><p>팀 프로그래밍을 할 때는 프로그래밍 세션은 모든 테스트가 성공한 상태로 끝마치는 것이 좋다.<br>팀 프로젝트에서는 자신이 마지막으로 코딩한 다음부터 지금까지 무슨 일이 있었는지 세밀하게 알 수 없다. 안심이 되고 확신이 있는 상태에서 시작할 필요가 있다.</p><hr><h1 id="초록-막대-패턴"><a href="#초록-막대-패턴" class="headerlink" title="초록 막대 패턴"></a>초록 막대 패턴</h1><p>빨간 막대(실패한 테스트)를 가능한 빨리 초록 막대(성공한 테스트)로 옮기기 위해 이 패턴들을 사용하라.</p><h2 id="가짜로-구현하기-진짜로-만들기-전까지만"><a href="#가짜로-구현하기-진짜로-만들기-전까지만" class="headerlink" title="가짜로 구현하기(진짜로 만들기 전까지만)"></a>가짜로 구현하기(진짜로 만들기 전까지만)</h2><p>실패하는 테스트를 만든 후 첫 번째 구현은 어떻게 하는 게 좋을까?<br><strong>상수를 반환하게 하라</strong><br><strong>일단 테스트가 통과하면 단계적으로 상수를 변수를 사용하는 수식으로 변형한다</strong></p><p>가짜로 구현하기를 강력하게 만드는 두 가지 효과가 있다.</p><ul><li>심리학적 : 막대가 초록색일 때 현재 어느 위치에 있는지 알 수 있다. 또 확신을 갖고 거기부터 리팩토링해 갈 수 있다.</li><li>범위(Scope) 조절 : 다음 테스트 케이스를 구현할 때, 이전 테스트의 작동이 보장된다는 것을 알기 때문에 그 다음 테스트 케이스에도 집중할 수 있다.</li></ul><p>필요 없는 코드는 조금도 작성하지 말라는 법칙에 가짜로 구현하기가 위배되는 것처럼 보일 수 있지만 <strong>리팩토링 단계에서 테스트 케이스와 코드 간의 데이터 중복을 제거</strong> 함으로써 해결 할 수 있다.</p><h2 id="삼각-측량"><a href="#삼각-측량" class="headerlink" title="삼각 측량"></a>삼각 측량</h2><p>추상화 과정을 테스트로 주도할 때 최대한 보수적으로 하기 위해 오로지 예가 두 개 이상일 때에만 추상화를 하라.</p><p> 만약 두 정수의 합을 반환하는 함수를 작성할 때</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquasl(<span class="number">4</span>, plus(<span class="number">3</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> augend, <span class="keyword">int</span> addend)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>삼각측량을 사용해 바른 설계로 간다면 다음과 같이 작성해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquasl(<span class="number">4</span>, plus(<span class="number">3</span>, <span class="number">1</span>));</span><br><span class="line">    assertEquasl(<span class="number">7</span>, plus(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>두 번째 예가 생겼을 때 plus() 구현을 추상화 할 수 있다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> augend, <span class="keyword">int</span> addend)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> augend + addend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>두 단언을 만들었고 plus 가 바른 구현을 추상화했면, 두 단언은 중복이 되기 때문에 하나를 제거 할 수 있다.<br>하지만 그렇게 하면 우리는 다시 상수를 반환하는 것으로 단순화할 수 있는데 그렇게 되면 다시 단언을 하나 추가하고, 무한 루프를 만들어 낼 수 있다.<br>그렇기 때문에 어떤 계산을 어떻게 해야 올바르게 추상화할 것인지에 대한 정말 감잡기 어려울 때 삼각측량을 사용하면 도움을 받을 수 있다.<br>그 외의 경우 명백한 구현이나 가짜로 구현하기에 의존한다.</p><h2 id="명백한-구현"><a href="#명백한-구현" class="headerlink" title="명백한 구현"></a>명백한 구현</h2><p>단순한 연산들은 그냥 구현해 버려라.<br>가짜로 구현하기와 삼각측량은 눈곱만큼 작은 발걸음이다. 때때로 어떤 연산을 어떻게 구현해야 할지 확신이 들기도 한다. 그럼 그렇게 하라. plus() 만큼 간단한 것도 하나의 예가 된다.<br>그냥 명백한 구현을 입력하고 만약 빨간 막대를 보고 놀란다면 그제서야 좀더 작은 발걸음으로 옮겨가라.</p><p>‘제대로 동작하는’을 푸는 동시에 ‘깨끗한 코드’를 해결하는 것은 한번에 하기에는 너무 많은 일일 수 있다. 그렇게 되면 우선 ‘제대로 동작하는’으로 되돌아 가서 그걸 해결하고, 그 후에  ‘깨끗한 코드’를 느긋하게 해결하도록 하라.</p><h2 id="하나에서-여럿으로"><a href="#하나에서-여럿으로" class="headerlink" title="하나에서 여럿으로"></a>하나에서 여럿으로</h2><p>객체 컬렉션(collection)을 다루는 연산은 일단은 컬렉션없이 구현하고 그 다음에 컬렉션을 사용하게 한다.</p><hr><h1 id="xUnit-패턴"><a href="#xUnit-패턴" class="headerlink" title="xUnit 패턴"></a>xUnit 패턴</h1><p>xUnit 계열 테스팅 프레임워크를 위한 패턴이다.</p><h2 id="단언-assertion"><a href="#단언-assertion" class="headerlink" title="단언(assertion)"></a>단언(assertion)</h2><p>테스트가 잘 작동하는지 Boolean 수식을 작성해 프로그램이 자동으로 코드가 동작하는지에 대한 판단을 수행하도록 해라.</p><h2 id="픽스쳐"><a href="#픽스쳐" class="headerlink" title="픽스쳐"></a>픽스쳐</h2><p>객체들을 원하는 상태로 세팅하는 코드를 작성하고 이 객체들을 조작하고 결과를 볼 수 있도록 테스트하는 코드를 작성한다.(이러한 객체들을 <strong>테스트 픽스처</strong> 혹은 Scaffolding 이라 칭한다.)<br><strong>이와 같은 중복은 작성하는데 시간이 소요되고, 인터페이스를 수동으로 변경할 때 여러 테스트를 고쳐주어야 하기에 문제가 발생한다.</strong><br>이 문제는 공통 코드들을 setUp() 함수로 추출해 모든 테스트 케이스가 setUp 함수를 호출하도록 해 해결할 수 있다. 하지만 공통 함수에서 객체들이 어떻게 초기화 되었는지는 계속해서 기억하고 있어야 한다. </p><p>하지만, 중복에도 좋은 점은 존재한다. 객체 세팅 코드들이 단언이 적힌 메서드에 포함되면 테스트 코드를 위에서 아래로 읽어가며 이해하기에 훨씬 수월하다.</p><p>위 두 가지 스타일은 장단점이 있으며 어떤 스타일을 사용할지는 두 가지 모두 시도해보는 것이 좋다.</p><h2 id="외부-픽스처"><a href="#외부-픽스처" class="headerlink" title="외부 픽스처"></a>외부 픽스처</h2><p>만약 테스트 중에 파일을 열었다면 테스트가 끝나기 전에 이를 반드시 닫아야 한다.<br>아래와 같이 코드를 작성할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setUp(self):</span><br><span class="line">    self.file = File(<span class="string">&quot;foo&quot;</span>).<span class="built_in">open</span>()</span><br><span class="line">tesMethod(self):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ...run the test...</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.file.close()</span><br></pre></td></tr></table></figure><p>하지만 이 코드를 여러 테스트에서 사용할 필요가 있다면, 귀찮은 중복이 될 수 있고 버그를 만들기 좋은 설계이다.</p><p>이렇게 픽스쳐 중 외부 자원이 있을 경우 xUnit이 제공하는 tearDown() 메서드를 재정의해 자원을 해제할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setUp(self):</span><br><span class="line">    self.file = File(<span class="string">&quot;foo&quot;</span>).<span class="built_in">open</span>()</span><br><span class="line">testMethod(self):</span><br><span class="line">    ...run the test...</span><br><span class="line">tearDown(self):</span><br><span class="line">    self.file.close()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://jeonjoonho.github.io/categories/Book-TDD/">Book TDD</category>
      
      
      <category domain="https://jeonjoonho.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/">소프트웨어</category>
      
      
      <comments>https://jeonjoonho.github.io/2021/02/11/%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EC%A3%BC%EB%8F%84%20%EA%B0%9C%EB%B0%9C%EC%9D%98%20%ED%8C%A8%ED%84%B4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Effective Java:2장 객체 생성과 파괴(작업 중)</title>
      <link>https://jeonjoonho.github.io/2020/11/11/2%EC%9E%A5%20%EA%B0%9D%EC%B2%B4%20%EC%83%9D%EC%84%B1%EA%B3%BC%20%ED%8C%8C%EA%B4%B4/</link>
      <guid>https://jeonjoonho.github.io/2020/11/11/2%EC%9E%A5%20%EA%B0%9D%EC%B2%B4%20%EC%83%9D%EC%84%B1%EA%B3%BC%20%ED%8C%8C%EA%B4%B4/</guid>
      <pubDate>Wed, 11 Nov 2020 07:01:39 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;2장-객체-생성과-파괴&quot;&gt;&lt;a href=&quot;#2장-객체-생성과-파괴&quot; class=&quot;headerlink&quot; title=&quot;2장. 객체 생성과 파괴&quot;&gt;&lt;/a&gt;2장. 객체 생성과 파괴&lt;/h1&gt;&lt;p&gt;목표 :&lt;br&gt;객체를 만들어야 할 때와 만들지 말아</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="2장-객체-생성과-파괴"><a href="#2장-객체-생성과-파괴" class="headerlink" title="2장. 객체 생성과 파괴"></a>2장. 객체 생성과 파괴</h1><p>목표 :<br>객체를 만들어야 할 때와 만들지 말아야 할 때를 구분하는 방법<br>올바른 객체 생성 방법과 불필요한 생성을 피하는 방법<br>제때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업을 관리하는 방법</p><h2 id="아이템-1-생성자-대신-정적-팩터리-메서드를-고려하라"><a href="#아이템-1-생성자-대신-정적-팩터리-메서드를-고려하라" class="headerlink" title="아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라"></a>아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라</h2><ul><li><p>클래스의 인스턴스를 얻는 수단은 Public 생성자와 정적 팩터리 메서드(Static Factory Method)가 있다.</p></li><li><p>예시</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Static Factory Method를 사용 했을 때의 장점</p><ol><li><strong>이름을 가질 수 있다.</strong><ul><li>생성자 자체는 반환될 객체의 특성을 설명하지 못 한다.</li><li>매개변수가 들어가는 생성자를 Static Factory Method로 변경하고 각각의 차이를 잘 드러내는 이름을 지정하면 타 개발자도 클래스 설명 문서 없이 의미를 이해하기 쉽다.</li></ul></li><li><strong>호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.</strong><ul><li>Immutable Class는 인스턴스를 미리 만들어 놓거나 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 막을 수 있다.</li><li>생성 비용이 큰 객체 같은 경우는 큰 성능의 이점을 볼 수 있다.</li><li>반복되는 요청에 같은 객체를 반환하는 식으로 어느 인스턴스를 살아 있게 할지를 통제할 수 있고, 이를 인스턴스 통제 클래스(Instace-Controlled)라 부른다.</li><li>인스턴스를 통제하면 싱글턴으로 만들 수도 있고, 인스턴스화 불가로 만들 수 있다.</li><li>인스턴스 통제는 플라이웨이트 패턴의 근간이 되고, 열거 타입은 인스턴스가 하나만 만들어짐을 보장한다.</li></ul></li><li><strong>반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.</strong><ul><li>반환할 객체의 클래스를 자유롭게 선택할 수 있으면 굉장한 유연성을 가질 수 있다.</li><li>이 유연성을 응용해 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지할 수 있다.</li><li>이 방법은 인터페이스를 Static Factory Method의 반환 타입으로 사용하는 인터페이스 기반 프레임워크를 만드는 핵심 기술이다.</li></ul></li><li><strong>입력 매개 변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.</strong><ul><li>반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환해도 된다.</li><li>예로 EnumSet 클래스는 원소의 수에 따라 하위 클래스 중 하나의 인스턴스를 반환한다.<ul><li>64개 이하면 long 변수 하나로 관리하는 RegularEnumSet</li><li>65개 이상이면 long 배열로 관리하는 JumboEnumSet</li></ul></li><li>유연하게 위와 비슷한 성능을 더 개선한 세 번째, 네 번째 클래스를 다음 배포 때 추가 할 수도 있다.</li></ul></li><li><strong>Static Factory Method를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.</strong><ul><li>서비스 제공자 프레임워크는 구현체의 동작을 정의하는 서비스 인터페이스, 제공자가 구현체를 등록할 때 사용하는 제공자 등록 API, 클라이언트가 서비스의 인스턴스를 얻을 ?때 사용하는 서비스 접근 API가 있다.</li><li>클라이언트가 서비스 접근 API를 사용하면 원하는 구현체의 조건을 명시할 수 있고, 명시하지 않으면 기본 구현체를 반환하거나 지원하는 구현체들을 하나씩 돌아가며 반환한다.</li><li>이 서비스 접근 API가 유연한 정적 팩터리의 장점을 사용하고 있다.</li></ul></li></ol></li><li><p>단점</p><ol><li><strong>상속을 하려면 public이나 protected 생성자가 필요하여 Static Factory Method만 제공하면 하위 클래스를 만들 수 없다.</strong></li><li><strong>Static Factory Method는 프로그래머가 찾기 어렵다.</strong></li></ol></li></ul><h2 id="아이템-2-생성자에-매개변수가-많다면-빌더를-고려하라"><a href="#아이템-2-생성자에-매개변수가-많다면-빌더를-고려하라" class="headerlink" title="아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라"></a>아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라</h2><ul><li><p>Static Factory와 생성자는 선택적 매개변수가 많을 때 적절히 대응하기 힘들다는 제약이 있다.</p></li><li><p><strong>선택적 매개변수가 많다면 생성자를 선언할 때 코드를 작성하거나 읽기 어렵다.</strong></p><ul><li><p>각 값의 의미가 무엇인지 헷갈리고, 몇 개인지도 주의해서 세어 보아야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola = <span class="keyword">new</span> NutritionFacts(<span class="number">240</span>, <span class="number">8</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">35</span>, <span class="number">27</span>);</span><br><span class="line"><span class="comment">// 코카콜라의 영양 정보를 담고 있는 클래스이다.</span></span><br><span class="line"><span class="comment">// 각 값의 의미가 무엇인지, 필수값이 무엇인지 전혀 알 수 없다.</span></span><br></pre></td></tr></table></figure></li><li><p>매개변수의 순서를 바꿔도 컴파일러에서는 에러가 나지 않고, 런타임에 엉뚱한 동작을 하게 된다.</p></li></ul></li><li><p>자바빈즈 패턴(JavaBeans Pattern)은 매개변수가 없는 생성자로 객체를 만든 후 Setter로 매개변수의 값을 설정하는 방식이다.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola = <span class="keyword">new</span> NutritionFacts();</span><br><span class="line">cocaCola.setServingSize(<span class="number">240</span>);</span><br><span class="line">cocaCola.setServings(<span class="number">8</span>);</span><br><span class="line">cocaCola.setCalories(<span class="number">100</span>);</span><br><span class="line">cocaCola.setSodium(<span class="number">35</span>);</span><br><span class="line">cocaCola.setCarbohydrate(<span class="number">27</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>자바빈즈 패턴에서는 객체 하나를 만들기 위해 여러 메서드를 호출해야하고, 완전히 생성되기 전까지는 일관성(consistency)이 무너진 상태이기에 클래스를 불변으로 만들 수 없다.</strong></li><li>스레드 안정성을 얻기 위해 프로그래머가 추가 작업을 해야 한다.</li><li>이러한 단점을 완화하기 위해 생성이 끝난 객체를 수동으로 얼리고(freezing) 얼리기 전에는 사용할 수 없도록 하기도 하지만 다루기 어려워 실무에서는 거의 사용하지 않는다.</li></ul></li><li><p>생성자 패턴의 안전성과 자바빈즈 패턴의 가독성, 두 가지 장점을 합친 빌더 패턴(Builder Pattern)이 세 번째 대안이 될 수 있다.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"><span class="comment">// 필수</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 선택</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="keyword">this</span>.servings = servings;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            calories = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            fat = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sodium</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            sodium = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">carbohydrate</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            carbohydrate = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories, <span class="keyword">int</span> fat, <span class="keyword">int</span> sodium, <span class="keyword">int</span> carbohydrate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">        <span class="keyword">this</span>.servings = servings;</span><br><span class="line">        <span class="keyword">this</span>.calories = calories;</span><br><span class="line">        <span class="keyword">this</span>.fat = fat;</span><br><span class="line">        <span class="keyword">this</span>.sodium = sodium;</span><br><span class="line">        <span class="keyword">this</span>.carbohydrate = carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NutritionFacts cocaCola = <span class="keyword">new</span> NutritionFacts.Builder(<span class="number">240</span>, <span class="number">8</span>)</span><br><span class="line">.calories(<span class="number">100</span>).sodium(<span class="number">35</span>).carbohydrate(<span class="number">27</span>).build();</span><br></pre></td></tr></table></figure><ul><li>불변인 객체를 얻을 수 있고, 코드를 작성하기 쉬우며 가독성도 좋다.</li><li>처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는 것이 더 낫다.</li></ul></li></ul><h2 id="아이템-3-private-생성자나-열거-타입으로-싱글턴임을-보증하라"><a href="#아이템-3-private-생성자나-열거-타입으로-싱글턴임을-보증하라" class="headerlink" title="아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라"></a>아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라</h2><ul><li><p>싱글턴(singleton)은 인스턴스를 오직 하나만 생성할 수 있는 클래스이다.</p><ul><li>함수와 같은 무상태 객체나 설계상 유일해야 하는 시스템 컴포넌트를 예로 들 수 있다.</li></ul></li><li><p>생성 방식</p><ul><li><p>생성자를 private으로 감추고 유일하게 인스턴스를 접근 할 수 있는 public static 멤버 함수를 생성한다.</p><ul><li><p>Elvis.INSTANCE를 초기화 할 때 생성자가 딱 한 번 호출되기 때문에 싱글턴을 보장한다.</p></li><li><p>단, 리플렉션 API인 AccessibleObject.setAccessible을 사용하면 private 생성자를 호출 할 수 있기 때문에 이를 방어하려면 생성자를 수정해 두 번째 객체 생성되지 않도록 예외 처리를 해야 한다.</p></li><li><p>해당 클래스가 싱글턴임이 API 명백히 드러나고, 간결하다는 장점을 가지고 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Elvist</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>생성자를 private으로 감추고 유일하게 인스턴스를 접근 할 수 있는 private static 멤버 함수를 생성한다.</p><ul><li><p>getInstance 함수가 항상 같은 객체의 참조를 반환하기 때문에 싱글턴을 보장한다.</p></li><li><p>장점</p><ul><li>싱글턴이 아니게 변경하기 쉽고 호출하는 스레드별로 다른 인스턴스를 넘겨주게 할 수 있다</li><li>정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다</li><li>정적 팩터리의 메서드 참조자를 Supplier로 사용할 수 있다</li></ul></li><li><p><strong>위의 장점들이 필요하지 않다면 public으로 선언하는 것이 좋다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Elvist</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> INSTANCE &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>위의 두 가지 방식은</p><ul><li>리플렉션에 대한 처리가 필요하다</li><li>직렬화, 역직렬화에 대한 따로 처리가 필요하다</li></ul></li><li><p>라는 단점을 가지고 있다</p></li><li><p>원소가 하나인 열거 타입을 선언한다.</p><ul><li><p>장점</p><ul><li>public 필드 방식보다 더 간결하고 추가 노력없이 직렬화가 가능하다</li><li>리플렉션에 의한 제 2의 인스턴스 생성을 막을 수 있다</li></ul></li><li><p>단, 싱글턴이 Enum 외의 클래스를 상속해야 한다면 사용 할 수 없다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">INSTANCE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="아이템-4-인스턴스화를-막으려거든-private-생성자를-사용하라"><a href="#아이템-4-인스턴스화를-막으려거든-private-생성자를-사용하라" class="headerlink" title="아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라"></a>아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라</h2></li></ul></li></ul></li><li><p>정적 메서드와 정적 필드만을 담은 유틸리티 성 클래스는 인스턴스화 되지 않아야 한다.</p></li><li><p>기본 생성자를 private 생성자로 선언하여 인스턴스화를 막을 수 있다.</p></li><li><p>추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.</p><ul><li>하위 클래스를 만들어 인스턴스화 할 수 있기 때문이다</li><li>다른 개발자가 상속해서 사용해라 라는 의미로 오해할 수 도 있어 큰 문제가 된다.</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://jeonjoonho.github.io/categories/Book-EffectiveJava/">Book EffectiveJava</category>
      
      
      <category domain="https://jeonjoonho.github.io/tags/JAVA/">JAVA</category>
      
      
      <comments>https://jeonjoonho.github.io/2020/11/11/2%EC%9E%A5%20%EA%B0%9D%EC%B2%B4%20%EC%83%9D%EC%84%B1%EA%B3%BC%20%ED%8C%8C%EA%B4%B4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Effective Java:1장 들어가기</title>
      <link>https://jeonjoonho.github.io/2020/10/23/1%EC%9E%A5%20%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0/</link>
      <guid>https://jeonjoonho.github.io/2020/10/23/1%EC%9E%A5%20%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0/</guid>
      <pubDate>Fri, 23 Oct 2020 07:01:39 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;1장-들어가기&quot;&gt;&lt;a href=&quot;#1장-들어가기&quot; class=&quot;headerlink&quot; title=&quot;1장. 들어가기&quot;&gt;&lt;/a&gt;1장. 들어가기&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;자바 8 도입된 기능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;람다&lt;/li&gt;
&lt;li&gt;스트</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1장-들어가기"><a href="#1장-들어가기" class="headerlink" title="1장. 들어가기"></a>1장. 들어가기</h1><ul><li><p>자바 8 도입된 기능</p><ul><li>람다</li><li>스트림</li><li>옵셔널</li><li>인터페이스의 디폴트 메서드</li></ul></li><li><p><strong>명료성</strong>과 <strong>단순성</strong>에서 규칙 대부분이 파생된다.</p><ul><li>컴포넌트는 사용자를 놀라게 하는 동작을 해서는 안된다.</li><li>컴포넌트는 가능한 한 작되, 너무 작아서도 안 된다.</li><li>코드는 복사되는 게 아니라 재사용되어야 한다.</li><li>컴포넌트 사이의 의존성은 최소로 유지해야 한다.</li><li>오류는 만들어지자마자 가능한 한 빨리 잡아야 한다. (되도록이면 컴파일타임에)</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://jeonjoonho.github.io/categories/Book-EffectiveJava/">Book EffectiveJava</category>
      
      
      <category domain="https://jeonjoonho.github.io/tags/JAVA/">JAVA</category>
      
      
      <comments>https://jeonjoonho.github.io/2020/10/23/1%EC%9E%A5%20%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Virtual Memory[가상 메모리]</title>
      <link>https://jeonjoonho.github.io/2020/08/04/VirtualMemory/</link>
      <guid>https://jeonjoonho.github.io/2020/08/04/VirtualMemory/</guid>
      <pubDate>Tue, 04 Aug 2020 07:01:39 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;개인적인 공부를 위해 작성한 글입니다. 맞지 않는 내용이 있다면 언제든지 의견 부탁드립니다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;가상-메모리란&quot;&gt;&lt;a href=&quot;#가상-메모리란&quot; class=&quot;headerlink&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>개인적인 공부를 위해 작성한 글입니다. 맞지 않는 내용이 있다면 언제든지 의견 부탁드립니다!</p></blockquote><h1 id="가상-메모리란"><a href="#가상-메모리란" class="headerlink" title="가상 메모리란"></a>가상 메모리란</h1><hr><ul><li>RAM을 관리하는 하나의 방법으로, 프로그램(프로세스)에게 실제 물리적 주소가 아닌 가상의 주소를 할당하는 방식이다.</li><li>가상적으로 주어진 주소를 가상 주소, 논리 주소라고 부르며 실제 메모리 상에 유효한 주소를 물리적 주소, 실 주소라고 한다.</li><li>가상 주소 공간은 MMU(Memory Manegement Unit)에 의해 물리적 주소로 변환된다.</li><li>한정된 크기의 메모리 내에 최대한 많은 프로세스를 할당하여 효율적으로 사용하기 위해 만든 기술로, 보조 기억장치를 주 기억장치처럼 사용할 수 있게 하는 기술이다.</li></ul><h1 id="가상-주소-공간"><a href="#가상-주소-공간" class="headerlink" title="가상 주소 공간"></a>가상 주소 공간</h1><hr><ul><li>개인 PC가 32비트 시스템이고, 2G 용량을 가진 RAM을 가지고 있다고 가정했을 때, 하나의 프로세스에 최대 4G를 할당할 수 있다.(2^32)</li><li>여기서 실제 물리적 메모리는 2G인데 두 배 용량을 가진 최대로 4G를 어떻게 할당할 수 있을까?</li></ul><p><img src="https://s3.ap-northeast-2.amazonaws.com/joon.dev/virtual-memory/virtual-memory-01.png" alt="Virtual%20Memory%20bdaad97584554105b2d36f9c7b00f3c2/Untitled.png"></p><p><strong>Memory Access Latency</strong><br>레지스터(1사이클) &lt; L1캐시(수사이클) &lt; L2캐시(수십사이클) &lt; Main Memory(수백사이클) &lt; Disk(수백만사이클)</p><ul><li>위의 메모리 계층 구조를 참고하면 보조기억장치라고 메인 메모리와 같은 역할을 하지 말라는 법은 없다. 다만 굉장히 느릴 뿐이다.</li><li>결국, <strong>메모리의 물리적 크기의 제한은 있지만 이를 초과하는 메모리 할당(가상 메모리)을 보조 기억 장치로 할 수 있다.</strong></li><li>즉 32비트 시스템에서 실제로 프로세스에게 할당할 수 있는 최대 크기인 4G이고, 이는 RAM과 같은 물리적 주소가 아닌 실제로 존재하지 않는 가상의 주소이다. 그리고 가상의 주소를 사용해 할당한 4G에 해당하는 공간을 <strong>가상 주소 공간</strong> 이라고 칭한다.</li></ul><h1 id="Page-Page-Frame"><a href="#Page-Page-Frame" class="headerlink" title="Page, Page Frame"></a>Page, Page Frame</h1><hr><p><img src="https://s3.ap-northeast-2.amazonaws.com/joon.dev/virtual-memory/virtual-memory-02.png" alt="Virtual%20Memory%20bdaad97584554105b2d36f9c7b00f3c2/Untitled%201.png"></p><ul><li>16비트 시스템에서 프로세스마다 가상 메모리를 64K(32비트 시스템은 4G)씩 할당하는 것은 낭비이다.</li><li>그래서 위 이미지의 왼쪽 막대처럼 64K의 가상 공간을 16개로 나누어 4K씩 할당 용량을 줄여 낭비되는 공간을 줄였으며, 이 **4K로 나눈 가상 주소 공간을 하나의 페이지(Page)**로 칭한다.</li><li>오른쪽 막대는 물리적 메모리 주소로 메인 메모리의 실제 주소 공간이다. 똑같이 주소 공간을 4K씩 할당받았으며 **4K로 나눈 물리적 주소 공간은 하나의 페이지 프레임(Page Frame)**으로 칭한다.</li></ul><h1 id="Page-Table"><a href="#Page-Table" class="headerlink" title="Page Table"></a>Page Table</h1><hr><p><img src="https://s3.ap-northeast-2.amazonaws.com/joon.dev/virtual-memory/virtual-memory-03.png" alt="Virtual%20Memory%20bdaad97584554105b2d36f9c7b00f3c2/Untitled%202.png"></p><ul><li>프로세스가 특정 메모리에 접근하려면 운영체제는 프로세스의 가상 주소를 물리적 주소로 변환을 하는데 이 과정에서 Page Table을 사용하게 된다.</li><li>Page Table은 가상 주소와 물리적 주소 맵핑 테이블이며, 개별 맵핑 데이터는 Page-Table-Entity라고 부른다.</li></ul><blockquote><p>Page Table은 프로세스마다 하나씩 존재하며 메인 메모리(RAM)에 상주하게 된다. 즉, 프로세스가 많이 구동될수록 Page Table로 인해 메인 메모리 사용이 증가하게 된다.</p></blockquote><h1 id="운영체제가-프로세스를-수행할-때-메인-메모리에-어떤-페이지를-어떻게-할당할까"><a href="#운영체제가-프로세스를-수행할-때-메인-메모리에-어떤-페이지를-어떻게-할당할까" class="headerlink" title="운영체제가 프로세스를 수행할 때 메인 메모리에 어떤 페이지를 어떻게 할당할까?"></a>운영체제가 프로세스를 수행할 때 메인 메모리에 어떤 페이지를 어떻게 할당할까?</h1><hr><ul><li>CPU가 명령을 수행할 때 해당 페이지를 <strong>“요구”**한다. : **Demend Paging 기법</strong></li></ul><h2 id="Demend-Paging"><a href="#Demend-Paging" class="headerlink" title="Demend Paging"></a>Demend Paging</h2><ul><li><p>MMU을 사용해 여러 프로세스가 효율적으로 메모리를 공유하는 기술</p></li><li><p>여러 프로세스가 하나의 시스템 메모리를 어떻게 공유해서 사용할 수 있을까?</p><ul><li>각 프로세스가 필요로 하는 모든 메모리(Code Segment, Data Segment, Stack Segment)가 물리적 메모리에 포함되어도 될까?</li><li>결과적으로는 포함되어 있지 않아도 되고, 그 이유는 프로세스가 **Locality(집약성)**을 가지고 있기 때문이다.</li></ul><blockquote><p><strong>Locality</strong> <br><br>프로세스가 가장 최근에 접근했던 데이터를 다시 접근(Temporal Locality)하거나, 최근에 참조한 데이터 근처의 주소를 참조(Spatial Locality)하는 경향이 있음.</p></blockquote><ul><li><p>그러므로 Locality 특성을 가진 프로세스의 모든 메모리를 물리적 메모리에 할당할 필요가 없다. 그러면 가상 주소 공간에 페이지들 중 물리적 메모리에 포함되어 있지 않은 페이지들은 어디로 가는 것 일까?</p><ul><li><strong>Swap Area(Swap Device)에 포함된다.</strong></li></ul><blockquote><p><strong>Swap Area(Swap Device)</strong> <br><br>물리적 메모리 공간에 포함되지 못한 Page들을 저장하는 Disk(보조기억장치)의 공간으로 File에 비해 운영체제가 직접 빠르게 접근할 수 있다. <br><br><em># File에 직접 접근하는 것은 굉장히 오래 걸리는 Operation이다. 그래서 Swap Device는 File에 한 부분으로 놓지 않고 Direct Access가 가능한 Low Disk Block에 위치한다.</em><br><br>Swap Device가 꽉 찬 경우에는 File로 저장하는 경우도 있다.</p></blockquote><ul><li>Swap Area로 저장 공간은 확보할 수 있지만 물리적 메모리와 memory transfer operation이 발생하게 된다.</li></ul></li></ul></li></ul><ul><li><p><strong>결국 Demend Paging의 목적은 물리적 메모리와 Swap Device 사이의 데이터 전송을 최소화 하기위함이다.</strong></p></li><li><p>이상적인 Demend Paging의 동작</p><ul><li>앞으로 사용될 페이지를 미리 알아서 물리적 메모리로 보내고, 사용 안할 페이지를 미리 알아서 Swap Device로 내보내는 것이다.</li><li>하지만 반대 상황이 된다면 메인 메모리에 Access할 때 계속해서 Swap Device로 Access를 하게 된다. 이 현상이 Trashing이다.</li></ul><p><strong>Trashing</strong><br>프로세스들이 사용하는 Page들의 크기보다 사용 가능한 물리적 메모리의 크기가 작을 때 발생하며, 사용하려는 Swap-in 하는 Page들에 의해 앞으로 사용할 Page가 Swap-out 되버려 반복적으로 Page Fault현상이 발생하는 것<br>초창기, 시분할 OS에 심각한 문제였다.</p></li></ul><h1 id="가상-주소-→-물리적-주소로-변환-과정"><a href="#가상-주소-→-물리적-주소로-변환-과정" class="headerlink" title="가상 주소 → 물리적 주소로 변환 과정"></a>가상 주소 → 물리적 주소로 변환 과정</h1><hr><p><img src="https://s3.ap-northeast-2.amazonaws.com/joon.dev/virtual-memory/virtual-memory-04.png" alt="Virtual%20Memory%20bdaad97584554105b2d36f9c7b00f3c2/Untitled%203.png"></p><ul><li>CPU의 MMU는 최근에 맵핑된 Page Table의 정보들을 **TLB(Translation Lookaside Buffer)**에 저장한다.</li></ul><blockquote><p>TLB는 자주 사용하는 Page Table의 주소를 저장하여 translation의 속도를 향상시켜주는 고속 SRAM으로 구성된 캐시 메모리이다.</p></blockquote><blockquote><p>MMU는 TLB에 접근하여 가상 메모리 주소를 물리 메모리 주소로 변환하거나 이에 실패하는 경우 보완 조치를 수행하는 순차 논리 회로이다.</p></blockquote><h3 id="변환-과정"><a href="#변환-과정" class="headerlink" title="변환 과정"></a>변환 과정</h3><ul><li>CPU가 가상 메모리에 접근을 시도하면 이 요청을 MMU가 중간에 가로챈다.</li><li>MMU가 TLB을 탐색해 그 가상 메모리 페이지가 실제 물리적 메모리 주소의 어느 프레임에 존재하는지 검색하여 검색에 성공(TLB hit)하면 물리 메모리 주소에 접근하여 CPU가 의도한 처리를 수행한다.</li><li>만약 TLB에서 탐색을 실패하면, 운영체제가 메인 메모리에 만든 Page Table을 CPU 자체 캐시 메모리에서 검색해보고 여기서도 탐색에 실패하면 비로소 메인 메모리에 있는 Page Table을 직접 검색해 물리적 메모리 주소에 접근하게 된다.(<strong>메인 메모리에 page table에서 검색하고 찾지 못 하면 디스크에서 찾는게 아닌가?</strong>)</li></ul><h3 id="변환-실패"><a href="#변환-실패" class="headerlink" title="변환 실패"></a>변환 실패</h3><ul><li>변환 과정에서 물리적 메모리 주소를 접근하지 못하는 2가지 경우가 있다.</li></ul><ol><li>가상 메모리 주소 자체가 유효하지 않은 경우<ul><li>이 경우에는 운영체제가 해당 가상 메모리 주소 접근을 요청한 프로세스에게 Segmentation Fault를 발생시킨다.</li></ul></li><li>가상 메모리 주소가 물리 메모리에 존재하지 않는 경우(일반적인 경우)<ul><li>해당 page가 다른 메모리 접근 요청에 의해 물리 메모리 공간이 부족해져 page out이 된 상황이다.</li><li>위의 상황에서 운영체제는 Page Fault를 발생시키고, 아래의 과정으로 다시 물리 메모리로 로드시킨다.<ul><li><strong>물리 메모리가 꽉 차지 않은 상태(empty frame이 존재할 때)</strong><ul><li>empty frame으로 로드시키고, Page Table과 TLB에 업데이트한다.</li></ul></li><li><strong>물리 메모리가 꽉 찬 상태</strong><ul><li>메인 메모리에서 empty frame으로 변경할 페이지를 찾는다.<ul><li><strong>Page Replacement Algorithm 사용</strong></li></ul></li><li>이 과정에서 사용하지 않는 page를 보조기억장치로 되돌려 보내는 <strong>스와핑 작업</strong>을 한다.</li><li>empty frame으로 로드시키고, Page Table과 TLB에 업데이트한다.</li></ul></li><li>위의 과정을 모두 처리 후에 물리 메모리 요청을 재게한다.</li></ul></li></ul></li></ol><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><hr><p><a href="http://egloos.zum.com/sweeper/v/2988646">http://egloos.zum.com/sweeper/v/2988646</a></p><p><a href="https://mooneegee.blogspot.com/2015/01/os-virtual-memory-3-page-page-frame.html">https://mooneegee.blogspot.com/2015/01/os-virtual-memory-3-page-page-frame.html</a></p><p><a href="https://post.naver.com/viewer/postView.nhn?volumeNo=17941943&memberNo=21815">https://post.naver.com/viewer/postView.nhn?volumeNo=17941943&amp;memberNo=21815</a></p><p><a href="https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81_%EB%A9%94%EB%AA%A8%EB%A6%AC">https://ko.wikipedia.org/wiki/가상_메모리</a></p><p>[<a href="https://jennysgap.tistory.com/312?category=818454%5D">https://jennysgap.tistory.com/312?category=818454]</a></p>]]></content:encoded>
      
      
      <category domain="https://jeonjoonho.github.io/categories/CS-OS/">CS OS</category>
      
      
      <category domain="https://jeonjoonho.github.io/tags/OS/">OS</category>
      
      
      <comments>https://jeonjoonho.github.io/2020/08/04/VirtualMemory/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>BigQuery ML이란</title>
      <link>https://jeonjoonho.github.io/2020/07/08/BigQuery%20ML/</link>
      <guid>https://jeonjoonho.github.io/2020/07/08/BigQuery%20ML/</guid>
      <pubDate>Wed, 08 Jul 2020 07:01:39 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;BigQuery-ML&quot;&gt;&lt;a href=&quot;#BigQuery-ML&quot; class=&quot;headerlink&quot; title=&quot;BigQuery ML&quot;&gt;&lt;/a&gt;BigQuery ML&lt;/h1&gt;&lt;p&gt;BigQuery에서 SQL을 사용하는 개발자, 데이터 분석가들</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="BigQuery-ML"><a href="#BigQuery-ML" class="headerlink" title="BigQuery ML"></a>BigQuery ML</h1><p>BigQuery에서 SQL을 사용하는 개발자, 데이터 분석가들이 기존 SQL 도구 및 기술을 이용해 ML 모델을 생성하고 실행할 수 있도록 해 머신러닝을 대중화하여 손쉽게 사용할 수 있도록 도와주는 툴.</p><p>ML 솔루션을 프로그래밍 할 필요가 없다. (SQL 쿼리를 사용해 모델을 학습시키고 액세스가 가능)</p><p>기존 BigQuery에 적재되고 있는 데이터들을 손 쉽게 사용할 수 있다. =&gt; 데이터를 내보내고 형식을 재지정 할 필요가 없어 모델 개발 속도가 향상될 수 있다.</p><p>현재 BigQuery ML에서 지원되는 모델</p><ul><li><p>예측용 선형 회귀</p><ul><li>회귀 : 가격이나 확률같이 연속된 출력 값을 예측</li><li>라벨은 실수, +/- 무한대 혹은 NaN</li><li>Ex) 특정 일의 상품 판매량, 자동차 연비 예측, 출생 시 체중 예측 등</li></ul></li><li><p>분류용 이진 로지스틱 회귀</p><ul><li><p>예측용 선형 회귀는 범위가 무한대라면 이진 로지스틱 회귀는 범위가 두 가지이다.</p></li><li><p>라벨에 가능한 값은 2가지.</p></li><li><p>Ex) 고객이 구매할지 여부 예측, 시험 합격, 불합격 여부 예측 등</p><p>  어뷰저 예측도 가능하지 않을까?</p></li></ul></li><li><p>분류용 다중 클래스 로지스틱 회귀</p><ul><li>이진 로지스틱 회귀는 두 가지를 분류하는 모델이고, 다중 클래스 로지스틱 회귀는 세 가지 이상을 분류하는 모델이다.</li><li>Ex) 꽃받침 길이, 꽃받침 넓이, 꽃잎 길이, 꽃잎 넓이를 나타내며 이로부터 setosa, versicolor, virginica라는 3개의 품종을 분류하는 문제</li></ul></li><li><p>데이터 세분화용 K-평균 클러스터링(K-means Clustering)</p><ul><li>입력받은 데이터를 N개의 클러스터링으로 분할</li><li>EX) 고객 세그먼트 식별 등</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://jeonjoonho.github.io/categories/ETC/">ETC</category>
      
      
      <category domain="https://jeonjoonho.github.io/tags/BigQuery-ML/">BigQuery ML</category>
      
      
      <comments>https://jeonjoonho.github.io/2020/07/08/BigQuery%20ML/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>누적확률</title>
      <link>https://jeonjoonho.github.io/2020/05/25/%EB%88%84%EC%A0%81%ED%99%95%EB%A5%A0/</link>
      <guid>https://jeonjoonho.github.io/2020/05/25/%EB%88%84%EC%A0%81%ED%99%95%EB%A5%A0/</guid>
      <pubDate>Mon, 25 May 2020 07:01:39 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;누적확률&quot;&gt;&lt;a href=&quot;#누적확률&quot; class=&quot;headerlink&quot; title=&quot;누적확률&quot;&gt;&lt;/a&gt;누적확률&lt;/h1&gt;&lt;h2 id=&quot;배경&quot;&gt;&lt;a href=&quot;#배경&quot; class=&quot;headerlink&quot; title=&quot;배경&quot;&gt;&lt;/a&gt;배경&lt;/h</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="누적확률"><a href="#누적확률" class="headerlink" title="누적확률"></a>누적확률</h1><h2 id="배경"><a href="#배경" class="headerlink" title="배경"></a>배경</h2><hr><ul><li>1-N까지 특정 확률을 적용한 숫자 값을 반환하는 로직<ul><li>ex) 1 60%, 2 20% 3 10% 4 7% 5 3%</li></ul></li></ul><h2 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h2><hr><ul><li><p>ruby는 rand() 함수를 내장하고 있어 난수를 쉽게 생성할 수 있다.</p><ul><li><p><strong>rand()</strong></p></li><li><p>rand()함수는 1~5개까지 난수를 생성할 때 20%의 확률(100% / 5)로 고르게 생성이 되는 것을 볼 수 있다.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">rand(<span class="number">1</span>..<span class="number">5</span>) <span class="comment"># 1 - 5 중에 랜덤한 난수를 생성</span></span><br><span class="line">=&gt; <span class="number">4</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 난수가 생성되는 확률을 계산하는 계산기 클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PercentagesCalculator</span></span></span><br><span class="line">  def <span class="keyword">self</span>.run(test_count)</span><br><span class="line">    counter = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line">    test_count.to_i.times <span class="keyword">do</span></span><br><span class="line">      <span class="comment"># 난수 생성 100번 실행(100% 기준으로 확률 계산하기 편하게 하기 위함)</span></span><br><span class="line">      percentage = <span class="number">100</span>.times.map <span class="keyword">do</span></span><br><span class="line">        rand(<span class="number">1</span>..<span class="number">5</span>) <span class="comment"># 1부터 5까지의 난수</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment"># 난수 카운팅</span></span><br><span class="line">      percentage_counter_hash = percentage.group_by&#123;<span class="params">|e|</span> e&#125;.map&#123;<span class="params">|k, v|</span> [k, v.length]&#125;.to_h</span><br><span class="line"> </span><br><span class="line">      <span class="comment"># 난수 별 총 합계 계산</span></span><br><span class="line">      counter.size.times <span class="keyword">do</span> <span class="params">|index|</span></span><br><span class="line">        counter[index] += percentage_counter_hash[index + <span class="number">1</span>] <span class="params">||</span> <span class="number">0</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 확률 계산</span></span><br><span class="line">    counter.map &#123; <span class="params">|result|</span> result / test_count.to_i &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 1000번 수행</span></span><br><span class="line"><span class="meta">&gt;&gt;</span> PercentagesCalculator.run(<span class="number">1000</span>)</span><br><span class="line">=&gt; [<span class="number">19</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">19</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>해결책 : 누적확률값</p><ul><li><p>만약 1 60%, 2 20% 3 10% 4 7% 5 3%의 확률로 리워드를 지급한다면 누적 확률 값은 5 3%, 4 10%, 3 20%, 2 40%, 1 100%을 가지게 된다.</p></li><li><p><strong>누적확률값 rand()</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 누적확률값을 이용한 난수 생성 함수</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_random_with_percentages</span><span class="params">(<span class="symbol">percentages:</span> [<span class="number">3</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">60</span>])</span></span></span><br><span class="line">  cumulative_percentages = cumulative_percentages(percentages)</span><br><span class="line"> </span><br><span class="line">  random = rand(<span class="number">0</span>..<span class="number">100</span>) <span class="comment"># 0 ~ 100% 까지</span></span><br><span class="line">  result = <span class="number">0</span></span><br><span class="line">  cumulative_percentages.each_with_index <span class="keyword">do</span> <span class="params">|percentage, index|</span></span><br><span class="line">    <span class="keyword">if</span> random &lt;= percentage</span><br><span class="line">      result = cumulative_percentages.size - index</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">  result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;</span> generate_random_reward_with_percentages</span><br><span class="line">=&gt; <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 난수가 생성되는 확률을 계산하는 계산기 클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PercentagesCalculator</span></span></span><br><span class="line">  def <span class="keyword">self</span>.run(test_count)</span><br><span class="line">    counter = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line">    test_count.to_i.times <span class="keyword">do</span></span><br><span class="line">      <span class="comment"># 난수 생성 100번 실행</span></span><br><span class="line">      percentage = <span class="number">100</span>.times.map <span class="keyword">do</span></span><br><span class="line">        generate_random_with_percentages(<span class="symbol">percentages:</span> [<span class="number">3</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">60</span>])</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment"># 난수 카운팅</span></span><br><span class="line">      percentage_counter_hash = percentage.group_by&#123;<span class="params">|e|</span> e&#125;.map&#123;<span class="params">|k, v|</span> [k, v.length]&#125;.to_h</span><br><span class="line"> </span><br><span class="line">      <span class="comment"># 난수 별 총 합계 계산</span></span><br><span class="line">      counter.size.times <span class="keyword">do</span> <span class="params">|index|</span></span><br><span class="line">        counter[index] += percentage_counter_hash[index + <span class="number">1</span>] <span class="params">||</span> <span class="number">0</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 확률 계산</span></span><br><span class="line">    counter.map &#123; <span class="params">|result|</span> result / test_count.to_i &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;</span> PercentagesCalculator.run(<span class="number">1000</span>)</span><br><span class="line">=&gt; [<span class="number">59</span>, <span class="number">20</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span>] <span class="comment"># 1 60%, 2 20% 3 10% 4 7% 5 3% 정해진 확률과 유사한 확률로 숫자가 생성됨.</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://jeonjoonho.github.io/categories/ETC/">ETC</category>
      
      
      <category domain="https://jeonjoonho.github.io/tags/%EB%88%84%EC%A0%81%ED%99%95%EB%A5%A0/">누적확률</category>
      
      
      <comments>https://jeonjoonho.github.io/2020/05/25/%EB%88%84%EC%A0%81%ED%99%95%EB%A5%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>IPC(Inter Process Communication)</title>
      <link>https://jeonjoonho.github.io/2020/04/25/IPC(Inter%20Process%20Communication)/</link>
      <guid>https://jeonjoonho.github.io/2020/04/25/IPC(Inter%20Process%20Communication)/</guid>
      <pubDate>Sat, 25 Apr 2020 07:01:39 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;개인적인 공부를 위해 작성한 글입니다. 맞지 않는 내용이 있다면 언제든지 의견 부탁드립니다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;IPC-사용-목적&quot;&gt;&lt;a href=&quot;#IPC-사용-목적&quot; class=&quot;headerl</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>개인적인 공부를 위해 작성한 글입니다. 맞지 않는 내용이 있다면 언제든지 의견 부탁드립니다!</p></blockquote><h1 id="IPC-사용-목적"><a href="#IPC-사용-목적" class="headerlink" title="IPC 사용 목적"></a>IPC 사용 목적</h1><hr><ul><li>각 프로세스는 독립적인 메모리 공간을 소유하고 있고 상황에 따라서 다른 프로세스와 협력이 필요할 때가 있다. 하지만 협력을 하게 되더라도 각 프로세스는 안전상의 이유로 다른 프로세스의 메모리를 직접 접근, 수정은 불가능하다. (다른 프로세스의 데이터를 잘 못 건드리다간 프로세스가 죽어버릴 수 있다.) 그렇기 때문에 프로세스는 다른 프로세스가 건드릴 수 없는 독립적인 메모리 공간을 소유하게 된다.</li><li>그래서 프로세스간의 데이터 공유가 필요 하며 IPC 기법을 사용해 정보 공유(Information Sharing), 계산 가속화(Computation speedup), 모듈성(Modularity), 편의성(Convenience)를 제공한다.</li></ul><p>계산 가속화 : 특정 작업을 빠르게 실행하기 위해, 해당 작업을 부분 작업으로 나눠 병렬로 실행<br>모듈성 : 특정 시스템 기능을 별도 프로세스(스레드)로 구분하여 모듈식 형태로 구성</p><h1 id="IPC-대표-모델"><a href="#IPC-대표-모델" class="headerlink" title="IPC 대표 모델"></a>IPC 대표 모델</h1><hr><ol><li><p>Meessage Passing</p><p> <img src="https://s3.ap-northeast-2.amazonaws.com/joon.dev/IPC/IPC-001.png" alt="IPC(Inter%20Process%20Communication)%207c810a65c07549918a2c29c398b715e2/Untitled.png"></p><ul><li>Memory Protection을 위해 커널(OS)을 거쳐 Message를 전달하는 방식이다.</li><li>Kernel을 활용하기 때문에 쉽게 구현이 가능하고 동기화 문제가 발생하지 않는다. 하지만 속도측면에서 Kernel을 거치기때문에 직접 전달하는 방식에 비해서는 느리고 전달할 때 System call이 발생하고 overhead가 발생하게 된다.</li><li>대표적인 기법 : PIPE, Message Queue, Socket 등</li></ul></li><li><p>Shared Memory</p><p> <img src="https://s3.ap-northeast-2.amazonaws.com/joon.dev/IPC/IPC-002.png" alt="IPC(Inter%20Process%20Communication)%207c810a65c07549918a2c29c398b715e2/Untitled%201.png"></p><ul><li>각 프로세스들이 특수한 메모리 공간을 공유하며, 공유한 메모리 공간에서 Read/Write를 통해 통신을 수행한다.</li><li>직접 호출하는 방식으로 System Call이 발생하지 않고 Kernel에 의존하지 않기 때문에 속도가 빠르다. 하지만 각 프로세스에 공유가 가능한 특수한 메모리 공간을 별도로 할당해주기 때문에 생성공간에 대한 제한이 존재한다.</li><li>Kernel이 동기화를 제공하지 않기 때문에 동시 접근에 대한 제어가 필요하며 Locking이나 세마포어 등을 이용한다.</li><li>대표적인 기법 : Shared Memeory, Memory Map</li></ul></li></ol><h1 id="대표적인-IPC-통신-기법"><a href="#대표적인-IPC-통신-기법" class="headerlink" title="대표적인 IPC 통신 기법"></a>대표적인 IPC 통신 기법</h1><hr><ol><li><p>PIPE</p><p> <img src="https://s3.ap-northeast-2.amazonaws.com/joon.dev/IPC/IPC-003.png" alt="IPC(Inter%20Process%20Communication)%207c810a65c07549918a2c29c398b715e2/Untitled%202.png"></p><ul><li>부모 자식간 두 개의 프로세스를 파이프로 연결하고, 하나의 프로세스는 데이터를 Write만, 다른 하나의 프로세스는 데이터를 Read만 한다.</li><li>한 쪽 방향으로만의 통신이고, Half-Duplex(반이중) 통신이라 부른다. 읽기/쓰기를 모두 하고싶다면 두 개의 파이프로 연결을 해야 한다.</li><li>매우 간단하게 사용할 수 있다는 장점이 있다</li></ul></li><li><p>Named PIPE(FIFO)</p><ul><li>부모와 자식간의 통신인 익명 PIPE와 달리 모르는 상태의 프로세스들과의 통신에 사용한다.</li></ul></li><li><p>Message Queue</p><p> <img src="https://s3.ap-northeast-2.amazonaws.com/joon.dev/IPC/IPC-004.png" alt="IPC(Inter%20Process%20Communication)%207c810a65c07549918a2c29c398b715e2/Untitled%203.png"></p><ul><li>입출력 방식은 Named PIPE와 동일하지만 PIPE가 데이터의 흐름이라면 메시지 큐는 메모리 공간이 존재한다.</li><li>메시지 큐에 사용할 데이터에 번호를 붙여 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있다.</li></ul></li><li><p>Shared Memory</p><ul><li>위의 방법들과는 달리 데이터를 직접 통신하는 것이 아닌 데이터를 공유하는 기법이다.</li><li>커널의 도움 없이 곧바로 메모리에 접근하기 때문에 다른 IPC 기법들 중에서 가장 빠르다.</li></ul></li><li><p>Memory Map</p><ul><li>Shared Memory와 같이 메모리를 공유는 기법이고 열린 파일을 메모리에 맵핑해 공유한다.</li><li>파일은 시스템 전역의 자원이므로 다른 프로세스들끼리 데이터를 공유하는데 문제가 없다는 점을 이용한 것이다.</li></ul></li><li><p>Socket</p><ul><li>네트워크 소켓통신을 사용한 데이터 공유이며, IPC 기법 중에 유일하게 다른 외부 시스템의 프로세스와도 공유가 가능하다.</li></ul></li></ol><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><hr><ul><li><a href="https://talkingaboutme.tistory.com/entry/Process-Inter-Process-Communication-IPC">https://talkingaboutme.tistory.com/entry/Process-Inter-Process-Communication-IPC</a></li><li><a href="https://jwprogramming.tistory.com/54">https://jwprogramming.tistory.com/54</a></li><li><a href="https://doitnow-man.tistory.com/110">https://doitnow-man.tistory.com/110</a></li><li><a href="https://jhnyang.tistory.com/24">https://jhnyang.tistory.com/24</a></li><li><a href="https://neos518.tistory.com/132">https://neos518.tistory.com/132</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://jeonjoonho.github.io/categories/CS-OS/">CS OS</category>
      
      
      <category domain="https://jeonjoonho.github.io/tags/OS/">OS</category>
      
      
      <comments>https://jeonjoonho.github.io/2020/04/25/IPC(Inter%20Process%20Communication)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TCP와 HTTP</title>
      <link>https://jeonjoonho.github.io/2020/03/20/TCP%EC%99%80%20HTTP/</link>
      <guid>https://jeonjoonho.github.io/2020/03/20/TCP%EC%99%80%20HTTP/</guid>
      <pubDate>Fri, 20 Mar 2020 07:01:39 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;개인적인 공부를 위해 작성한 글입니다. 맞지 않는 내용이 있다면 언제든지 의견 부탁드립니다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;TCP&quot;&gt;&lt;a href=&quot;#TCP&quot; class=&quot;headerlink&quot; title=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>개인적인 공부를 위해 작성한 글입니다. 맞지 않는 내용이 있다면 언제든지 의견 부탁드립니다!</p></blockquote><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><ol><li>HTTP 통신을 위해 Client-Server는 three-way handshake를 거쳐 TCP 연결을 구축한다.</li><li>Client가 TCP SYN 세그먼트를 만들어 데이터그램을 Web Server에 전송한다.</li><li>각 Web 서버의 네트워크 아키텍쳐(방화벽, 로드밸런스, API 게이트웨이 등)를 거쳐 도달한 SYN 메시지를 추출해 Client와 TCP 소켓 연결을 하기 위해, Client로 SYNACK 세그먼트를 생성해 Client에 전송한다.</li><li>SYNACK 메시지를 받은 Client는 Server에 ACK 메시지를 보내고 TCP 연결을 하게 된다.</li></ol><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><ol><li>Web HTTP Server는 Client로 부터 HTTP GET 메시지를 읽고, HTTP 응답 메시지에 요청받은 콘텐츠의 내용을 Body에 담아 Client로 응답한다.</li><li>Server로 부터 응답을 받은 Client는 HTTP 응답 메시지를 읽고 해당 콘텐츠를 렌더링한다.</li></ol><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><ul><li>TLS Handshake 과정을 거쳐 SSL 인증서를 이용해 HTTP 요청, 응답 메시지를 암호화해 보안을 강화한 기술이다.</li></ul><ol><li>Client가 Client Random 문자열을 생성해 ClientHello 메시지에 담아 Server에 전송한다.</li><li>ClientHello 메시지를 받은 Server는 SSL 인증서와 Server Random 메시지를 담아 ServerHello 메시지를 응답한다.</li><li>Client는 서버로 응답 받은 SSL 인증서의 유효성을 검증해 해당 Web Server의 소유자 라는 것을 확인하고, 서버에게 공개키로 암호화한 Random 문자열을 보낸다. Random 문자열을 Pre-Master Secret Key라 부르며, 해당 WebServer의 비밀키로만 복호화가 가능하다.</li><li>Server는 Client로 부터 Pre-Master Secret Key를 받고 자신의 Secret Key로 복호화하여 Server Random 문자열, Client Random 문자열, Pre-Master Secret Key를 이용해 세션키를 생성한다. 이 세션키는 Client와 Server 모두 동일해야 한다.</li><li>Client와 Server가 세션키로 암호화된 Finished 메시지를 주고 받으며 TLS Handshake 과정을 마친다.</li><li>Client와 Server는 위의 세션 키를 이용해 대칭 키 방식으로 TLS 통신을 하며, 실제 HTTP 통신의 패킷을 확인하면 TLS로 암호화되어 내용을 확인할 수 없다.</li></ol>]]></content:encoded>
      
      
      <category domain="https://jeonjoonho.github.io/categories/CS-Network/">CS Network</category>
      
      
      <category domain="https://jeonjoonho.github.io/tags/Network/">Network</category>
      
      
      <comments>https://jeonjoonho.github.io/2020/03/20/TCP%EC%99%80%20HTTP/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ARP(Address Resolutino Protocol)</title>
      <link>https://jeonjoonho.github.io/2020/03/15/ARP(Address%20Resolution%20Protocol)/</link>
      <guid>https://jeonjoonho.github.io/2020/03/15/ARP(Address%20Resolution%20Protocol)/</guid>
      <pubDate>Sun, 15 Mar 2020 07:01:39 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;개인적인 공부를 위해 작성한 글입니다. 맞지 않는 내용이 있다면 언제든지 의견 부탁드립니다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;ARP-Address-Resolution-Protocol&quot;&gt;&lt;a href=&quot;#ARP</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>개인적인 공부를 위해 작성한 글입니다. 맞지 않는 내용이 있다면 언제든지 의견 부탁드립니다!</p></blockquote><h1 id="ARP-Address-Resolution-Protocol"><a href="#ARP-Address-Resolution-Protocol" class="headerlink" title="ARP(Address Resolution Protocol)"></a>ARP(Address Resolution Protocol)</h1><ul><li>네트워크 상에서 IP 주소를 물리적 네트워크 주소(MAC주소)를 대응시키기 위한 프로토콜(TCP/IP 3계층(네트워크 계층)의 IP 주소 → 2계층(데이터링크 계층) 으로 변환)</li><li>목적지의 IP 주소를 알지만, MAC 주소를 모를 때 target MAC 주소 00:00:00:00:00:00으로 채우고 패킷의 목적지를 FF:FF:FF:FF:FF:FF로 브로드캐스팅을 이용해 target MAC 주소를 얻는 것.</li><li>반대의 경우는 RARP Protocol.</li></ul><h1 id="과정"><a href="#과정" class="headerlink" title="과정"></a>과정</h1><p>Client ARP 메시지 생성 → AP → AP의 Eternet으로 연결된 스위치로 BroadCasting으로 자신에게 연결된 모든 장비에 프레임 전송 → Local DNS 서버 ARP 메시지를 받고 응답 프레임 전송 → 스위치 → AP → Client</p>]]></content:encoded>
      
      
      <category domain="https://jeonjoonho.github.io/categories/CS-Network/">CS Network</category>
      
      
      <category domain="https://jeonjoonho.github.io/tags/Network/">Network</category>
      
      
      <comments>https://jeonjoonho.github.io/2020/03/15/ARP(Address%20Resolution%20Protocol)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DNS</title>
      <link>https://jeonjoonho.github.io/2020/03/15/DNS/</link>
      <guid>https://jeonjoonho.github.io/2020/03/15/DNS/</guid>
      <pubDate>Sun, 15 Mar 2020 07:01:39 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;개인적인 공부를 위해 작성한 글입니다. 맞지 않는 내용이 있다면 언제든지 의견 부탁드립니다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;DNS-Protocol&quot;&gt;&lt;a href=&quot;#DNS-Protocol&quot; class=&quot;h</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>개인적인 공부를 위해 작성한 글입니다. 맞지 않는 내용이 있다면 언제든지 의견 부탁드립니다!</p></blockquote><h1 id="DNS-Protocol"><a href="#DNS-Protocol" class="headerlink" title="DNS Protocol"></a>DNS Protocol</h1><ul><li>도메인 네임을 IP 주소로 변환하기 위해 사용한다.</li><li>클라이언트는 DNS Query 메시지를 담은 프레임을 Local DNS 서버에 보내고, Loal DNS 서버에 정보가 없을경우 ISP DNS 서버로 전송한다.</li><li>만약 ISP DNS 서버가 특정 도메인의 IP를 차단한다면 warning.co.kr의 IP 주소로 응답한다.</li></ul><h1 id="DNS-서버를-통한-IP-주소-응답-과정"><a href="#DNS-서버를-통한-IP-주소-응답-과정" class="headerlink" title="DNS 서버를 통한 IP 주소 응답 과정"></a>DNS 서버를 통한 IP 주소 응답 과정</h1><ol><li>Client는 Local DNS 서버의 IP 주소만 알고 MAC 주소를 알지 못 하기 때문에 <a href="https://www.notion.so/jh/ARP-Address-Resolution-Protocol-d0b36c4fd4fa4ef29177de1a6cb7abff">ARP</a>를 이용해 MAC 주소를 얻는다.</li><li>Client는 도메인 네임이 담긴 DNS Query 메시지를 만들고 Local DNS 서버로 향하는 수신지 IP가 담긴 IP 데이터그램과 UDP 세그먼트를 붙인다. </li><li>Client → AP → Switch → Local DNS 서버로 프레임을 전송한다.</li><li>Local DNS 서버가 만약 도메인 네임을 알고 있다면 바로 IP 주소를 응답해주고, 만약 모른다면 Root DNS 서버로 DNS 쿼리를 전송한다. (* Root DNS 서버는 전세계의 13개만 존재하고 다양한 나라의 미러 서버가 존재한다.)</li><li>Local DNS 서버의 MAC 주소를 얻는 과정과 동일하게 ARP를 이용해 Root DNS 서버의 MAC 주소를 얻고 DNS Query 메시지를 전송한다.</li><li>DNS Query 프레임을 받은 Root DNS 서버는 (도메인이 <a href="http://www.google.com이라/">www.google.com이라</a> 가정할 때) TLD(Top Level Domain)이 .com인 것을 확인하고 com TLD 서버의 IP 주소를 응답한다.</li><li>응답을 받은 Local DNS 서버는 com TLD 서버에게 DNS Query를 보내고 com TLD 서버는 DNS 리소스 레코드를 확인해 응답한다.</li><li>만약, com TLD 서버가 <a href="http://www.google.com/">www.google.com</a>의 IP 주소를 모른다면 구글의 네임서버 IP를 응답하고 구글 네임서버는 호스트네임을 IP 주소를 매핑한 데이터를 담아 <a href="http://www.google.com의/">www.google.com의</a> IP 주소를 응답한다.</li></ol><p>[참고 이미지]</p><p><img src="https://s3.ap-northeast-2.amazonaws.com/joon.dev/DNS/DNS-001.png" alt="DNS%207ee3fa9799774e87907ee2e184cdc6a0/Untitled.png"></p><h1 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h1><hr><ul><li><a href="https://judo0179.tistory.com/37">https://judo0179.tistory.com/37</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://jeonjoonho.github.io/categories/CS-Network/">CS Network</category>
      
      
      <category domain="https://jeonjoonho.github.io/tags/Network/">Network</category>
      
      
      <comments>https://jeonjoonho.github.io/2020/03/15/DNS/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DHCP IP 주소 할당</title>
      <link>https://jeonjoonho.github.io/2020/03/14/DHCP%20IP%20%EC%A3%BC%EC%86%8C%20%ED%95%A0%EB%8B%B9/</link>
      <guid>https://jeonjoonho.github.io/2020/03/14/DHCP%20IP%20%EC%A3%BC%EC%86%8C%20%ED%95%A0%EB%8B%B9/</guid>
      <pubDate>Sat, 14 Mar 2020 07:01:39 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;개인적인 공부를 위해 작성한 글입니다. 맞지 않는 내용이 있다면 언제든지 의견 부탁드립니다! &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Client-→-AP-연결&quot;&gt;&lt;a href=&quot;#Client-→-AP-연결&quot; cla</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>개인적인 공부를 위해 작성한 글입니다. 맞지 않는 내용이 있다면 언제든지 의견 부탁드립니다! </p></blockquote><h1 id="Client-→-AP-연결"><a href="#Client-→-AP-연결" class="headerlink" title="Client → AP 연결"></a>Client → AP 연결</h1><p>AP는 자신의 범위에 있는 모든 Client들에게 Beacon 프레임을 BroadCasting하여 자신의 존재를 알려 Client는 그 중 특정 AP에 연결할 수 있다. 이런 형태가 AP가 신호를 보내는 방식으로 Passive Scanning이라 한다.</p><p>Client는 특정 AP에 접속 요청 프레임을 전송하고 AP는 응답 프레임을 Client에 전송하여 연결을 하게 된다.</p><p>첫 연결을 하게 될 때는 Client에게 IP 주소가 주어지지 않은 상태이며, **DHCP(Dynamic Host Configuration Protocol)**서버를 통해 IP 주소를 할당 받게 된다.</p><p>DHCP서버는 AP, Router가 동작 할 수 있다.</p><h1 id="DHCP-IP-주소-할당-임대"><a href="#DHCP-IP-주소-할당-임대" class="headerlink" title="DHCP IP 주소 할당(임대)"></a>DHCP IP 주소 할당(임대)</h1><p>DHCP서버는 Discover, Offer, Request, Ack 총 4번의 과정을 통해 IP 주소를 할당하게 된다.</p><h3 id="1-DHCP-Discover-Client-→-DHCP-Server"><a href="#1-DHCP-Discover-Client-→-DHCP-Server" class="headerlink" title="1. DHCP Discover(Client → DHCP Server)"></a>1. DHCP Discover(Client → DHCP Server)</h3><ul><li>UDP(User Datagram Protocol) 통신을 사용</li><li>Client는 할당받은 IP 주소가 없기 때문에 src, yiaddr는 0.0.0.0이다.</li><li>DHCP 서버의 IP 주소를 알지 못하기 때문에 LAN(동일 Subnet)상에 BroadCasting 을 통해 DHCP 서버의 응답을 기다린다. (dest: 255.255.255.255)</li><li>수신지 MAC 주소(FF:FF:FF:FF:FF:FF), 발신지 MAC 주소(Client MAC 주소)</li></ul><h3 id="2-DHCP-Offer-DHCP-Server-→-Client"><a href="#2-DHCP-Offer-DHCP-Server-→-Client" class="headerlink" title="2. DHCP Offer(DHCP Server → Client)"></a>2. DHCP Offer(DHCP Server → Client)</h3><ul><li>Client가 보낸 메시지의 broadcast flag에 따라 0: Unicast, 1: Broadcast로 전송</li><li>Client에 할당하기 위한 IP 주소를 선택해 Offer 메시지를 만든다.</li><li>Client가 IP 주소를 할당받을 수 있는 시간을 포함해서 메시지를 만든다.(IP Lease Time)</li><li>수신지 MAC 주소(Client Mac 주소), 발신지 MAC 주소(AP MAC 주소)</li></ul><h3 id="3-DHCP-Request-Client-→-DHCP-Server"><a href="#3-DHCP-Request-Client-→-DHCP-Server" class="headerlink" title="3. DHCP Request(Client → DHCP Server)"></a>3. DHCP Request(Client → DHCP Server)</h3><ul><li>DHCP Offer에서 받은 메시지의 값을 바탕으로 자신의 설정 값을 포함해 Request 메시지를 생성한다.</li><li>여러 Offer 메시지를 받았다면 그 중 하나의 Offer만 선택해서 메시지를 생성한다.</li></ul><h3 id="4-DHCP-Ack-DHCP-Server-→-Client"><a href="#4-DHCP-Ack-DHCP-Server-→-Client" class="headerlink" title="4.DHCP Ack(DHCP Server → Client)"></a>4.DHCP Ack(DHCP Server → Client)</h3><ul><li>Client가 보낸 메시지의 broadcast flag에 따라 0: Unicast, 1: Broadcast로 전송</li><li>DHCP 주소 할당의 마지막 메시지이고, Client 네트워크 정보를 전달해주고, IP 주소는 Offer에서 제공한 IP 주소와 동일하다.</li><li>Client는 Ack 메시지를 추출해 자신의 IP 주소와 DNS IP 주소를 기록한다.</li><li>할당된 IP 주소는 임대한 것이기 때문에 일정 기간 사용하지 않으면 다시 반납되고, 새로운 IP 주소를 할당 받아야 한다.</li></ul><h1 id="DHCP-장점"><a href="#DHCP-장점" class="headerlink" title="DHCP 장점"></a>DHCP 장점</h1><ul><li>PC의 수가 많거나 PC의 변동 사항이 많아도 동적으로 IP 주소가 변경되기 때문에 효율적으로 사용이 가능하다.</li><li>IP 주소의 충돌이 발생하지 않는다.</li></ul><h1 id="DHCP-단점"><a href="#DHCP-단점" class="headerlink" title="DHCP 단점"></a>DHCP 단점</h1><ul><li>DHCP 서버가 문제가 생기면 IP 주소 할당이 되지 않는다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://jeonjoonho.github.io/categories/CS-Network/">CS Network</category>
      
      
      <category domain="https://jeonjoonho.github.io/tags/Network/">Network</category>
      
      
      <comments>https://jeonjoonho.github.io/2020/03/14/DHCP%20IP%20%EC%A3%BC%EC%86%8C%20%ED%95%A0%EB%8B%B9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Process</title>
      <link>https://jeonjoonho.github.io/2020/01/15/Process/</link>
      <guid>https://jeonjoonho.github.io/2020/01/15/Process/</guid>
      <pubDate>Wed, 15 Jan 2020 07:01:39 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;개인적인 공부를 위해 작성한 글입니다. 맞지 않는 내용이 있다면 언제든지 의견 부탁드립니다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Process란&quot;&gt;&lt;a href=&quot;#Process란&quot; class=&quot;headerlin</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>개인적인 공부를 위해 작성한 글입니다. 맞지 않는 내용이 있다면 언제든지 의견 부탁드립니다!</p></blockquote><h1 id="Process란"><a href="#Process란" class="headerlink" title="Process란"></a>Process란</h1><hr><p><img src="https://s3.ap-northeast-2.amazonaws.com/joon.dev/Process/process-001.png" alt="Process%20b38e6841b7654cb89ed910be181b8abc/Untitled.png"></p><ul><li><strong>컴퓨터에서 연속적으로 실행되고 있는 프로그램</strong></li><li>메모리에 적재되어 운영체제의 제어를 받고 있는 상태이며, 자신만의 메모리 영역을 소유하고 있다는 것을 의미한다.</li><li>각각 독립된 메모리 영역을 소유한다.(Stack, Heap, Data, Code)<ul><li>Stack: 프로세스가 실행 시키는 명령어</li><li>Heap: 동적 할당을 위한 메모리 영역</li><li>Data: 전역 변수</li><li>Stack: 지역 변수, 함수 파라미터</li></ul></li><li>프로세스 당 최소 스레드를 1개(메인 스레드) 이상 소유한다.</li><li>OS로 부터 시스템 자원을 할당 받는 작업의 단위</li><li>각 프로세스는 별도의 주소 공간을 가지며, 다른 프로세스의 데이터의 접근 할 수 없다.</li><li>만약 다른 프로세스와 데이터를 공유 하려면 파이프, 파일, 소켓 등 별도의 통신 작업(IPC - Inter-Process Communication)이 필요하다.</li><li>프로세스에 대한 정보는 PCB(Process Control Block)라는 자료구조에 저장된다.</li></ul><h1 id="Process-Control-Block"><a href="#Process-Control-Block" class="headerlink" title="Process Control Block"></a>Process Control Block</h1><hr><ul><li>특정한 프로세스를 관리할 필요가 있는 정보를 포함하는, 운영체제 커널의 자료 구조이다.</li><li><strong>각 프로세스는 고유의 PCB를 가지게 된다.</strong></li></ul><h3 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h3><ul><li>운영체제가 각 프로세스를 식별하기 위한 프로세스 번호</li></ul><h3 id="프로세스-상태"><a href="#프로세스-상태" class="headerlink" title="프로세스 상태"></a>프로세스 상태</h3><ul><li>CPU는 프로세스를 빠르게 교체하면서 실행하기 때문에 프로세스는 대기 상태, 실행 상태 등 프로세스의 상태를 저장한다.</li></ul><h3 id="PC-Program-Counter"><a href="#PC-Program-Counter" class="headerlink" title="PC(Program Counter)"></a>PC(Program Counter)</h3><ul><li>CPU가 다음으로 실행할 명령어를 가리키는 값입니다. CPU는 기계어를 한 단위씩 읽어서 처리하는데 프로세스를 실행하기 위해 다음으로 실행할 기계어가 저장된 메모리 주소를 가리키는 값입니다.</li></ul><h3 id="스케쥴링-우선순위"><a href="#스케쥴링-우선순위" class="headerlink" title="스케쥴링 우선순위"></a>스케쥴링 우선순위</h3><ul><li>OS는 동시에 여러 프로세스를 실행하기 위한 스케쥴링 작업을 하게 되는데 해당 프로세스의 우선순위를 저장한다.</li></ul><h3 id="권한"><a href="#권한" class="headerlink" title="권한"></a>권한</h3><ul><li>프로세스가 접근할 수 있는 자원을 결정하는 정보를 저장한다.</li></ul><h3 id="부모와-자식-프로세스"><a href="#부모와-자식-프로세스" class="headerlink" title="부모와 자식 프로세스"></a>부모와 자식 프로세스</h3><ul><li>Init 프로세스를 제외하고는 모든 프로세스는 부모 프로세스에서 fork되서 생성되며 트리 구조로 형성이 되기 때문에 각 프로세스는 부모와 자식 프로세스의 자식 정보를 저장한다.</li></ul><h3 id="프로세스의-데이터와-명령어가-있는-메모리-위치를-가리키는-포인터"><a href="#프로세스의-데이터와-명령어가-있는-메모리-위치를-가리키는-포인터" class="headerlink" title="프로세스의 데이터와 명령어가 있는 메모리 위치를 가리키는 포인터"></a>프로세스의 데이터와 명령어가 있는 메모리 위치를 가리키는 포인터</h3><h3 id="프로세스에-할당된-자원들을-가리키는-포인터"><a href="#프로세스에-할당된-자원들을-가리키는-포인터" class="headerlink" title="프로세스에 할당된 자원들을 가리키는 포인터"></a>프로세스에 할당된 자원들을 가리키는 포인터</h3><h3 id="Register-save-area-레지스터-관련-정보"><a href="#Register-save-area-레지스터-관련-정보" class="headerlink" title="Register save area : 레지스터 관련 정보"></a>Register save area : 레지스터 관련 정보</h3><h1 id="Process-Shceduling"><a href="#Process-Shceduling" class="headerlink" title="Process Shceduling"></a>Process Shceduling</h1><hr><ul><li>프로세스들 사이의 우선 순위를 관리하는 작업</li><li><strong>처리율과 CPU 이용률을 높이기 위해 오버헤드/응답 시간/반환 시간/대기시간을 최소화 하기 위한 기법</strong><ul><li>CPU가 쉬지 않도록 효율적인 계획을 세워 주자!</li></ul></li><li>스케쥴링은 단기, 중기, 장기 스케쥴링이 있다.<ul><li>장기: 어떤 프로세스를 커널에 등록 할 것인가?</li><li>중기: 어떤 프로세스에게 메모리를 할당할 것인가?</li><li>단기: 어떤 프로세스에게 CPU를 할당할 것인가?</li></ul></li></ul><p><img src="https://s3.ap-northeast-2.amazonaws.com/joon.dev/Process/process-002.png" alt="Process%20b38e6841b7654cb89ed910be181b8abc/Untitled%201.png"></p><h3 id="스케쥴링-결정-시점"><a href="#스케쥴링-결정-시점" class="headerlink" title="- 스케쥴링 결정 시점"></a>- 스케쥴링 결정 시점</h3><ul><li>프로세스의 상태 변화가 있을 때<ul><li>수행 → 대기 (비 선점, 선점)</li><li>수행 → 준비 (선점)</li><li>대기 → 준비 (선점)</li><li>수행 → 준비 (비 선점, 선점)</li></ul></li></ul><p><strong>* 비 선점 형 스케쥴링**<br>어떤 프로세스가 CPU를 할당 받으면 프로세스가 종료 되거나 I/O 요구로 인해 자발적으로 중지 될 때까지 실행하며, 순서대로 처리되어 공정성이 있고 응답 시간을 예상할 수 있으며 스케쥴러 호출 빈도가 낮고 Context Switching에 의한 오버헤드가 적다. 하지만 CPU 사용 시간이 짧은 프로세스도 오랜 대기 시간을 가질 수 있고, CPU 사용률이 떨어질 수 있다.<br>*</strong> 선점 형 스케쥴링**<br>어떤 프로세스가 CPU를 할당 받고 사용중이여도 다른 프로세스가 강제로 CPU를 점유 할 수 있다.<br>모든 프로세스에게 동일한 CPU 점유 시간을 부여할 수 있으며 빠른 응답 시간을 요구하는 대화식 시스템에 적합하다.</p><h1 id="Process-상태"><a href="#Process-상태" class="headerlink" title="Process 상태"></a>Process 상태</h1><hr><h3 id="Running"><a href="#Running" class="headerlink" title="Running"></a>Running</h3><ul><li>CPU를 잡고 명령어를 수행중인 상태</li></ul><h3 id="Ready"><a href="#Ready" class="headerlink" title="Ready"></a>Ready</h3><ul><li>CPU를 기다리는 상태</li><li>queue에서 대기하고 있는 상태를 의미한다. : 물리적 메모리에 코드가 올라와있는 상태</li></ul><h3 id="Blocked-wait-sleep"><a href="#Blocked-wait-sleep" class="headerlink" title="Blocked(wait, sleep)"></a>Blocked(wait, sleep)</h3><ul><li>당장 CPU를 할당해도 명령어를 수행할 수 없는 상태</li><li>I/O작업, 일부러 Sleep한 상태</li></ul><h3 id="New"><a href="#New" class="headerlink" title="New"></a>New</h3><ul><li>프로세스가 생성중인 상태</li></ul><h3 id="Terminated"><a href="#Terminated" class="headerlink" title="Terminated"></a>Terminated</h3><ul><li>execution이 끝나고 종료중인 상태</li></ul><h1 id="Process-상태-변화"><a href="#Process-상태-변화" class="headerlink" title="Process 상태 변화"></a>Process 상태 변화</h1><hr><p><img src="https://s3.ap-northeast-2.amazonaws.com/joon.dev/Process/process-002.png" alt="Process%20b38e6841b7654cb89ed910be181b8abc/Untitled%202.png"></p><ul><li>new → ready<ul><li>프로세스가 생성되면 OS kernel에 존재하는 Ready Queue에 Inqueue</li></ul></li><li>ready → running<ul><li>Ready Queue에 있는 프로세스를 스케쥴링 알고리즘에 의해 선별된 프로세스를 CPU로 할당한다.</li></ul></li><li>running → ready<ul><li>선점 형 스케쥴링일 때 현재 실행되고 있는 프로세스가 Ready Queue에 대기하고 있던 B 프로세스보다 우선 순위가 낮으면 B 프로세스에게 CPU를 할당한다.</li></ul></li><li>running → block<ul><li>프로세스에서 I/O 이벤트가 발생하게 되면 block 상태로 전이된다.</li></ul></li><li>blocked → ready<ul><li>프로세스의 I/O 이벤트가 종료되면 Ready 상태로 전이된다.</li></ul></li><li>running → terminate<ul><li>프로세스의 모든 명령어를 수행하고 종료한다.</li></ul></li></ul><blockquote><p>ready, blocked 상태는 여러 프로세스가 존재할 수 있다.<br>싱글코어 CPU에서는 running 상태의 프로세스는 단 하나이다.</p></blockquote><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><hr><ul><li><a href="https://junsday.tistory.com/28">https://junsday.tistory.com/28</a></li><li><a href="https://jhnyang.tistory.com/33">https://jhnyang.tistory.com/33</a></li><li><a href="https://blockdmask.tistory.com/22">https://blockdmask.tistory.com/22</a></li><li><a href="https://bowbowbow.tistory.com/16">https://bowbowbow.tistory.com/16</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://jeonjoonho.github.io/categories/CS-OS/">CS OS</category>
      
      
      <category domain="https://jeonjoonho.github.io/tags/OS/">OS</category>
      
      
      <comments>https://jeonjoonho.github.io/2020/01/15/Process/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Thread</title>
      <link>https://jeonjoonho.github.io/2020/01/15/Thread/</link>
      <guid>https://jeonjoonho.github.io/2020/01/15/Thread/</guid>
      <pubDate>Wed, 15 Jan 2020 07:01:39 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;개인적인 공부를 위해 작성한 글입니다. 맞지 않는 내용이 있다면 언제든지 의견 부탁드립니다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Thread란&quot;&gt;&lt;a href=&quot;#Thread란&quot; class=&quot;headerlink&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>개인적인 공부를 위해 작성한 글입니다. 맞지 않는 내용이 있다면 언제든지 의견 부탁드립니다!</p></blockquote><h1 id="Thread란"><a href="#Thread란" class="headerlink" title="Thread란"></a>Thread란</h1><hr><p><img src="https://s3.ap-northeast-2.amazonaws.com/joon.dev/Thread/thread-001.png" alt="Thread%20d76570bb5d1f46aab7446bdd11fb1900/Untitled.png"></p><ul><li>프로세스 내에서 실행되는 세부 작업의 단위, 흐름</li><li>프로세스 안에 최소 1 개 이상의 스레드(메인 스레드)가 포함되어있다.</li><li>스레드는 스택과 레지스터를 독립적인 메모리 공간에 가지고 있고, Code, Data, Heap 메모리 공간을 공유한다.</li><li>프로세스의 자원들을 공유할 수 있기 때문에 공통의 목적을 달성하기 위해 병렬로 수행이 가능하다.</li></ul><h1 id="Thread를-사용해서-얻는-이점"><a href="#Thread를-사용해서-얻는-이점" class="headerlink" title="Thread를 사용해서 얻는 이점"></a>Thread를 사용해서 얻는 이점</h1><hr><h3 id="응답성-Responsiveness"><a href="#응답성-Responsiveness" class="headerlink" title="응답성(Responsiveness)"></a><strong>응답성(Responsiveness)</strong></h3><ul><li>응용 프로그램의 일부분이 Block 또는 긴 시간의 작업을 수행해도 다른 작업은 계속해서 실행이 되어 사용자에 대한 응답성이 증가한다.</li></ul><h3 id="자원-공유-Resource-Sharing"><a href="#자원-공유-Resource-Sharing" class="headerlink" title="자원 공유(Resource Sharing)"></a>자원 공유(Resource Sharing)</h3><ul><li>스레드는 그들이 속한 프로세스의 자원을 공유하기 때문에 시스템 향상과 편의성을 제공한다.</li></ul><h3 id="경제성-economy"><a href="#경제성-economy" class="headerlink" title="경제성(economy)"></a>경제성(economy)</h3><ul><li>프로세스 마다 자원과 메모리를 할당하면 overhead가 증가하는데, 한 프로세스의 속한 여러 스레드는 자원과 메모리를 공유하기 때문에 경제성이 증가한다.</li><li><strong>스레드는 프로세스보다 컨텍스트 스위칭(Context Switching)이 빠르다.</strong></li></ul><h1 id="스레드가-프로세스보다-Context-Switching이-빠른-이유"><a href="#스레드가-프로세스보다-Context-Switching이-빠른-이유" class="headerlink" title="스레드가 프로세스보다 Context Switching이 빠른 이유"></a>스레드가 프로세스보다 Context Switching이 빠른 이유</h1><hr><ul><li>만약 프로세스 사이에서 Context Switching이 필요하게 되면 기존에 가지고 있던 이전 프로세스의 메모리를 저장하고 있는 캐시 메모리를 모두 리셋하고 새로운 프로세스의 메모리를 다시 캐시 메모리에 저장한다. 스레드는 프로세스 내부에서 메모리를 공유하고 있기 때문에 스레드 스택에 관련된 레지스터 정보만 몇 개 바꾸는 과정만 있고 캐시 메모리를 갱신할 필요가 없기 때문에 Context Switching 소요 시간이 더 빠르다.</li><li>위와 같은 이유로 다중 프로세스 보다 다중 스레드 환경이 더욱 빠르다.</li></ul><p><strong>Cache Memory</strong><br>CPU에서 한 번 이상 읽은 메인 메모리의 데이터를 저장하고 있다가 다시 CPU가 저장된 데이터를 필요로 할 때 메인 메모리를 통하지 않고 바로 값을 전달한다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><hr><ul><li><a href="https://ykcb.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C">https://ykcb.tistory.com/entry/운영체제-프로세스와-쓰레드</a></li><li><a href="https://boanin.tistory.com/84">https://boanin.tistory.com/84</a></li><li><a href="https://lalwr.blogspot.com/2016/02/process-thread.html">https://lalwr.blogspot.com/2016/02/process-thread.html</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://jeonjoonho.github.io/categories/CS-OS/">CS OS</category>
      
      
      <category domain="https://jeonjoonho.github.io/tags/OS/">OS</category>
      
      
      <comments>https://jeonjoonho.github.io/2020/01/15/Thread/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
